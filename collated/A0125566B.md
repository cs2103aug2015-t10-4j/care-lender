# A0125566B
###### carelender\controller\Search.java
``` java
package carelender.controller;

import java.util.Date;
import java.util.HashMap;

import carelender.model.data.*;

/**
 * Handles all search and sorting queries. Not just by the user, but also by the program.
 */

public class Search {
    public static boolean eventMatchesParams (Event eventToCheck,
                                        HashMap<QueryList.SearchParam, Object> paramsList) {
        boolean match = false;

        if (hasNameExact(paramsList)) {
            Object name = paramsList.get(QueryList.SearchParam.NAME_EXACT);
            assert ( name != null ) : "NAME_EXACT paired with null object in HashMap.";
            if (name instanceof String) {
                match = isEventNameExact(eventToCheck, (String)name);
            }

            if ( !match ) {
                return false;
            }
        }

        if (hasNameContains(paramsList)) {
            Object name = paramsList.get(QueryList.SearchParam.NAME_CONTAINS);
            assert ( name != null ) : "NAME_CONTAINS paired with null object in HashMap.";
            if (name instanceof String) {
                match = isEventNameMatch(eventToCheck, (String)name);
            }

            if ( !match ) {
                return false;
            }
        }

        if (hasCategory(paramsList)) {
            Object category = paramsList.get(QueryList.SearchParam.CATEGORY);
            assert ( category != null ) : "CATEGORY paired with null object in HashMap.";
            if (category instanceof String) {
                match = isEventInCategory(eventToCheck, (String)category);
            }

            if ( !match ) {
                return false;
            }
        }

        if (hasComplete(paramsList)) {
            Object complete = paramsList.get(QueryList.SearchParam.COMPLETE);
            assert ( complete != null ) : "CATEGORY paired with null object in HashMap.";
            match = IsEventComplete(eventToCheck, (Boolean)complete);

            if ( !match ) {
                return false;
            }
        }

        if (hasDateRange(paramsList)) {
            Object startDate = paramsList.get(QueryList.SearchParam.DATE_START);
            Object endDate = paramsList.get(QueryList.SearchParam.DATE_END);
            if ( startDate == null && endDate == null ) {
                match = isEventFloating(eventToCheck);
            } else if (startDate instanceof Date && endDate instanceof Date) {
                match = isEventInDateRange(eventToCheck,
                                                (Date)startDate, (Date)endDate);
            }

            if ( !match ) {
                return false;
            }
        } else if (hasStartDate(paramsList)) {
            Object startDate = paramsList.get(QueryList.SearchParam.DATE_START);
            if (startDate instanceof Date) {
                match = isEventAfterDate(eventToCheck, (Date)startDate);
            }

            if ( !match ) {
                return false;
            }
        } else if (hasEndDate(paramsList)) {
            Object endDate = paramsList.get(QueryList.SearchParam.DATE_END);
            if (endDate instanceof Date) {
                match = isEventBeforeDate(eventToCheck, (Date)endDate);
            }

            if ( !match ) {
                return false;
            }
        }
        return match;
    }

    public static boolean hasNameExact (HashMap<QueryList.SearchParam, Object> paramsList) {
        return paramsList.containsKey(QueryList.SearchParam.NAME_EXACT);
    }

    public static boolean hasNameContains (HashMap<QueryList.SearchParam, Object> paramsList) {
        return paramsList.containsKey(QueryList.SearchParam.NAME_CONTAINS);
    }

    public static boolean hasCategory (HashMap<QueryList.SearchParam, Object> paramsList) {
        return paramsList.containsKey(QueryList.SearchParam.CATEGORY);
    }

    public static boolean hasComplete (HashMap<QueryList.SearchParam, Object> paramsList) {
        return paramsList.containsKey(QueryList.SearchParam.COMPLETE);
    }

    public static boolean hasStartDate (HashMap<QueryList.SearchParam, Object> paramsList) {
        return paramsList.containsKey(QueryList.SearchParam.DATE_START);
    }

    public static boolean hasEndDate (HashMap<QueryList.SearchParam, Object> paramsList) {
        return paramsList.containsKey(QueryList.SearchParam.DATE_END);
    }

    public static boolean hasDateRange (HashMap<QueryList.SearchParam, Object> paramsList) {
        return (hasStartDate(paramsList) && hasEndDate(paramsList));
    }

    public static boolean isEventNameMatch (Event eventToCheck,
                                        String stringToCheck) {
        String eventName = eventToCheck.getName();
        if (eventName != null) {
            if(eventName.contains(stringToCheck)) {
                return true;
            }
        }
        return false;
    }

    public static boolean isEventNameExact (Event eventToCheck,
                                        String stringToCheck) {
        String eventName = eventToCheck.getName();
        if (eventName != null) {
            if (eventName.equals(stringToCheck)) {
                return true;
            }
        }
        return false;
    }

    public static boolean isEventInCategory (Event eventToCheck,
                                                String stringToCheck) {
        String categoryName = eventToCheck.getCategory();
        if (categoryName != null) {
            if (categoryName.equals(stringToCheck)) {
                return true;
            }
        } else {
            if (stringToCheck == null) {
                return true;
            }
        }
        return false;
    }

    public static boolean IsEventComplete (Event eventToCheck, boolean complete) {
        return eventToCheck.getCompleted() == complete;
    }

    public static boolean isEventBeforeDate (Event eventToCheck,
                                        Date startDate) {
        if ( eventToCheck != null ) {
            if ( eventToCheck.getDateRange() == null ) {
                if ( startDate == null ) {
                    return true;
                }
            }
            Date latestDate = eventToCheck.getLatestDate();
            if (latestDate != null) {
                if (!latestDate.after(startDate)) {
                    return true;
                }
            }
        }
        return false;
    }

    public static boolean isEventAfterDate (Event eventToCheck,
                                        Date endDate) {
        if ( eventToCheck != null ) {
            if ( eventToCheck.getDateRange() == null ) {
                if ( endDate == null ) {
                    return true;
                }
            }
            Date earliestDate = eventToCheck.getEarliestDateFromNow();
            if (earliestDate != null) {
                if (!earliestDate.before(endDate)) {
                    return true;
                }
            }
        }
        return false;
    }
    public static boolean isEventFloating ( Event eventToCheck ) {
        if ( eventToCheck != null ) {
            if (eventToCheck.getDateRange() == null) {
                return true;
            }
        }
        return false;
    }
    public static boolean isEventInDateRange (Event eventToCheck,
                                        Date startDate, Date endDate) {
        if ( eventToCheck != null ) {
            if ( eventToCheck.getDateRange() != null ) {
                for (DateRange dateRange : eventToCheck.getDateRange()) {
                    if ((!dateRange.getStart().before(startDate) && !dateRange.getStart().after(endDate))
                            || (!dateRange.getEnd().before(startDate) && !dateRange.getEnd().after(endDate))) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public static boolean isDateInEvent (Event eventToCheck, Date date) {
        if ( eventToCheck != null ) {
            for ( DateRange dateRange : eventToCheck.getDateRange() ) {
                if ((date.before(dateRange.getEnd()) || date.equals(dateRange.getEnd()))
                    && (date.after(dateRange.getStart()) || date.equals(dateRange.getStart()))) {
                    return true;
                }
            }
        }
        return false;
    }
}
```
###### carelender\model\data\DateRange.java
``` java
package carelender.model.data;

import java.io.Serializable;
import java.util.Date;
import java.util.concurrent.TimeUnit;

/*
 * Data object to help with managing task time ranges.
 * Used by:
 * 			EventObject
 */

public class DateRange implements Serializable{
    private Date start;
    private Date end;
    private boolean hasTime;

    public DateRange ( DateRange dateRange ) {
        start = (Date)dateRange.getStart().clone();
        end = (Date)dateRange.getEnd().clone();
        hasTime = dateRange.hasTime;
    }

    public DateRange (Date date, boolean hasTime) {
        start = end = date;
        this.hasTime = hasTime;
    }

    public DateRange (Date startToSet, Date endToSet, boolean hasTime) {
        if (!endToSet.after(startToSet)) {
            this.start = endToSet;
            this.end = startToSet;
        } else {
            this.start = startToSet;
            this.end = endToSet;
        }
        this.hasTime = hasTime;
    }


    public Date getEnd () {
        return end;
    }

    public void setEnd (Date end) {
        if (this.start != null) {
            if (!end.after(this.start)) {
                this.end = this.start;
                return;
            }
        }
        this.end = end;
    }

    public Date getStart () {
        return start;
    }

    public void setStart (Date start) {
        if (this.end != null) {
            if (!start.before(this.end)) {
                this.start = this.end;
                return;
            }
        }
        this.start = start;
    }

    /**
     * Return number of days between the start and end date.
     *
     * @return
     * 		Number of days between two dates.
     */
    public long getDaysBetween () {
        if ( isRange() ) {
            long difference = this.end.getTime() - this.start.getTime();
            long days = TimeUnit.DAYS.convert(difference, TimeUnit.MILLISECONDS);
            return days <= 0 ? 0 : days;
        }
        return 0;
    }

    /**
     * Checks if this is a range or just a single point in time
     * @return true if this is a range
     */
    public boolean isRange() {
        return start != end;
    }

    public DateRange copy () {
        return new DateRange(this);
    }

    public String toString () {
        if ( isRange() ) {
            return start.toString() + " - " + end.toString();
        } else {
            return start.toString();
        }
    }

    public boolean hasTime() {
        return hasTime;
    }
}
```
###### carelender\model\data\Event.java
``` java
package carelender.model.data;

import carelender.model.strings.DateFormats;

import java.io.Serializable;
import java.util.Date;

/**
 * Events are stored in this format when returned from the Storage component.
 * EventObjects should be within EventLists when returned from Storage.
 * 		Single objects are returned in an EventList of one element.
 * Used by:
 * 			EventList
 */

public class Event implements Serializable{
    private int uid;
    private String name;
    private boolean completed;
    //If dateRange is null, task is a FLOATING_TASK.
    //Deadline tasks have DateRange with same start and end date.
    private DateRange[] dateRange;
    private DateRecurrence dateRecurrence;
    private Date dateCreated;
    private String category;

    public Event ( Event eventObject ) {
        uid = eventObject.uid;
        name = eventObject.name;
        category = eventObject.category;
        completed = eventObject.completed;
        DateRange [] eventObjectDateRange = eventObject.dateRange;
        
        if ( eventObjectDateRange != null ) {
            dateRange = new DateRange[eventObjectDateRange.length];
            for ( int i = 0 ; i < eventObjectDateRange.length; i++ ) {
                dateRange[i] = eventObjectDateRange[i].copy();
            }
        } else {
            dateRange = null;
        }

        if(dateRecurrence != null) {
            dateRecurrence = eventObject.dateRecurrence.copy();
        }
    }
    public Event (int uidToSet, String nameToSet, DateRange[] dateRangetoSet, String category) {
        this.uid = uidToSet;
        this.name = nameToSet;
        this.dateRange = dateRangetoSet;
        this.category = category;
    }

    public void setUid(int uid){
        this.uid = uid;
    }
    public int getUid() {
        return uid;
    }

    public void setName (String nameToSet) {
        this.name = nameToSet;
    }
    public String getName () {
        return this.name;
    }
  
    public void setCompleted(Boolean completed) {
        this.completed = completed;
    }
    public boolean getCompleted(){
        return completed;
    }
    
    public void setDateRange (DateRange[] dateRangeToSet) {
        this.dateRange = dateRangeToSet;
    }
    public DateRange[] getDateRange () {
        return this.dateRange;
    }

    public void setDateCreated(Date dateCreated) {
        this.dateCreated = dateCreated;
    }

    public Date getDateCreated() {
        return dateCreated;
    }
 
    public void setCategory(String category) {
        this.category = category;
    }
    public String getCategory() {
        return category;
    }
    
```
###### carelender\model\data\Event.java
``` java
    public Date getLatestDate () {
        Date lastDate = null;
        if ( this.dateRange == null ) return null;
        for (DateRange dateR : this.dateRange) {
            if (lastDate == null) {
                lastDate = dateR.getEnd();
            } else {
                if (dateR.getEnd().after(lastDate)) {
                    lastDate = dateR.getEnd();
                }
            }
        }
        return lastDate;
    }

```
###### carelender\model\data\Event.java
``` java
    public Date getEarliestDate () {
        Date firstDate = null;
        if ( this.dateRange == null ) return null;
        for (DateRange dateR : this.dateRange) {
            if (firstDate == null) {
                firstDate = dateR.getStart();
            } else {
                if (dateR.getStart().before(firstDate)) {
                    firstDate = dateR.getStart();
                }
            }
        }
        return firstDate;
    }
    
```
###### carelender\model\data\Event.java
``` java
    public Date getEarliestDateFromNow () {
        Date currentDate = new Date();
        Date firstDate = null;
        if ( this.dateRange == null ) return null;
        for (DateRange dateR : this.dateRange) {
            if (dateR.getStart().after(currentDate) || dateR.getEnd().after(currentDate)) {
                if (firstDate == null) {
                    firstDate = dateR.getStart();
                } else {
                    if (dateR.getStart().before(firstDate)) {
                        firstDate = dateR.getStart();
                    }
                }
            }
        }
        return firstDate;
    }
    
    public EventType getEventType () {
        if (this.dateRecurrence == null) {
            if (this.dateRange == null) {
                return EventType.FLOATING_TASK;
            } else {

            }
        } else {
            if (this.dateRange == null) {
                return EventType.REC_FLOATING_TASK;
            }
        }
        return EventType.DEADLINE_TASK;
    }

    public String getInfo() {
        String dateString = DateFormats.DEBUG_FORMAT.format(getEarliestDate());
        return this.uid + " | " + this.name + " | " + dateString;
    }
```
###### carelender\model\data\Event.java
``` java
    public enum EventType {
        FLOATING_TASK,
        DEADLINE_TASK,
        SINGLE_RANGE_EVENT,
        MUTLI_RANGE_EVENT,
        REC_FLOATING_TASK,
        REC_DEADLINE_TASK,
        REC_SINGLE_RANGE_EVENT,
        REC_MULTI_RANGE_EVENT
    };
}
```
###### carelender\model\data\EventList.java
``` java
package carelender.model.data;

import java.util.ArrayList;

/*
 * Returned from Storage, list of tasks and events after operations such as retrieve.
 * Used by:
 * 			Storage
 * 			Logic
 */

public class EventList extends ArrayList<Event> {
    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        String breakline = "";
        int count = 0;
        for ( Event eventObject : this ) {
            count++;
            stringBuilder.append(breakline);
            breakline = System.lineSeparator();
            stringBuilder.append(count);
            stringBuilder.append(". ");
            stringBuilder.append(eventObject.getInfo());
        }
        return stringBuilder.toString();
    }
}
```
###### carelender\model\data\QueryList.java
``` java
package carelender.model.data;

import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

import carelender.controller.Controller;
import carelender.controller.Search;
import carelender.model.Model;

/**
 * Used for list queries
 */
public class QueryList extends QueryBase {
    private HashMap<SortParam, Comparator<Event>> sortComparators = new HashMap<>();
    private HashMap<SearchParam, Object> searchParamsList = new HashMap<>();

    private void defineComparators () {
        sortComparators.put(SortParam.NAME, ( Event eventAgainst, Event eventTo) -> {
                return eventAgainst.getName().compareTo(eventTo.getName());
            }
        );
        sortComparators.put(SortParam.DATE, (Event eventAgainst, Event eventTo) -> {
                if (eventAgainst.getEarliestDate().before(eventTo.getEarliestDate())) {
                    return 1;
                } else if (eventAgainst.getEarliestDate().after(eventTo.getEarliestDate())) {
                    return -1;
                }
                return 0;
            }
        );
    }

    public QueryList() {
        super(QueryType.LIST);
        this.defineComparators();
    }

    public QueryList (QueryType type) {
        super(type);
        this.defineComparators();
    }

    public void addSearchParam (SearchParam key, Object value) {
        this.searchParamsList.put(key, value);
    }

    public HashMap<SearchParam, Object> getSearchParamsList () {
        return this.searchParamsList;
    }

    public enum SearchParam {
        DATE_START,
        DATE_END,
        NAME_CONTAINS,
        NAME_EXACT,
        CATEGORY,
        COMPLETE,
        LIMIT,
        SORT
    };

    public enum SortParam {
        NAME,
        DATE
    };

    @Override
    public void controllerExecute() {
        EventList searchResults = searchExecute();

        if ( this.searchParamsList.containsKey(SearchParam.SORT) ) {
            SortParam sortType = (SortParam)this.searchParamsList.get(SearchParam.SORT);
            Collections.sort(searchResults, this.sortComparators.get(sortType));
        }

        Controller.displayTasks(searchResults);
    }

    @Override
    public EventList searchExecute() {
        EventList returnList = new EventList();

        if (Model.getInstance().retrieveEvent() != null) {
            for (Event event : Model.getInstance().retrieveEvent()) {
                if (Search.eventMatchesParams(event, getSearchParamsList())) {
                    returnList.add(event.copy());
                }
            }
        }
        return returnList;
    }
}
```
###### carelender\model\data\QueryType.java
``` java
package carelender.model.data;

/**
 * Used for determining the type of query
 */
public enum QueryType {
    ERROR,      //Invalid command entered
    ADD,        //Adding new event
    DELETE,     //Deleting an event
    REMINDER,   //Setting reminder for an event
    UPDATE,     //Updating an event
    HELP,       //Showing the help list
    LIST,       //Listing tasks
    CLEAR,       //Clears the message screen
    UNDO,       //Undo command
    REDO,       //Redo command
    COMPLETE,      //Complete and uncomplete command
    SHOW,           //Show details command
    SWITCHUI,       //Switching of the UI
    DATETEST,       //Used for testing date parsing
    SET,            //Used for customize setting
    EXIT,           //Exits the program
}
```
###### carelender\model\data\QueryUpdate.java
``` java
package carelender.model.data;

import java.util.HashMap;

import carelender.controller.Controller;
import carelender.controller.callbacks.OnConfirmedCallback;
import carelender.model.Model;
import carelender.model.strings.QueryFeedback;

/**
 * Used for update queries
 */
public class QueryUpdate extends QueryList {
    HashMap<UpdateParam, Object> updateParamsList = new HashMap<>();;
    EventList updateList;
    
    public QueryUpdate() {
        super(QueryType.UPDATE);
        updateList = new EventList();
    }
    
    public void addEvent ( Event e ) {
        updateList.add(e.copy());
    }
    
    public void addUpdateParam (UpdateParam key, Object value) {
        this.updateParamsList.put(key, value);
    }

    public HashMap<UpdateParam, Object> getUpdateParamsList () {
        return updateParamsList;
    }
    
    public enum UpdateParam {
        NAME,
        DATE_RANGE,
        CATEGORY
    };

    @Override
    public void controllerExecute() {
        Controller.clearMessages();

        final OnConfirmedCallback updateConfirmedCallback = new OnConfirmedCallback() {
            @Override
            public void onConfirmed(boolean confirmed) {
                if ( confirmed ) {
                    for ( Event event : updateList ) {
                        System.out.println("UPDATING:" + (String)updateParamsList.get(QueryUpdate.UpdateParam.NAME));
                        if ( updateParamsList.containsKey(QueryUpdate.UpdateParam.NAME) ) {
                            String fromName = (String)updateParamsList.get(QueryUpdate.UpdateParam.NAME);
                            event.setName(fromName);
                        }

                        if ( updateParamsList.containsKey(QueryUpdate.UpdateParam.DATE_RANGE) ) {
                            DateRange[] fromDateRange = (DateRange[])updateParamsList.get(QueryUpdate.UpdateParam.DATE_RANGE);
                            event.setDateRange(fromDateRange);
                        }

                        if ( updateParamsList.containsKey(QueryUpdate.UpdateParam.CATEGORY) ) {
                            String category = (String)updateParamsList.get(QueryUpdate.UpdateParam.CATEGORY);
                            event.setCategory(category);
                        }
                        //Model.getInstance().updateEvent(event);
                        System.out.println(event.getName());
                    }
                    Model.getInstance().updateEvent(updateList);
                    Controller.refreshDisplay();
                } else {
                    Controller.displayMessage(QueryFeedback.updateCancelled());
                }
            }
        };

        if ( updateList.size() > 1 ) {
            if ( updateParamsList.containsKey(QueryUpdate.UpdateParam.DATE_RANGE) ) {
                Controller.displayMessage("Cannot bulk update dates! Will cause conflicts");
            } else {
                Controller.getBlockingStateController()
                .startConfirmation("Are you sure you want to update " + updateList.size() + " events? [Y/N]", updateConfirmedCallback);
            }
        } else if ( updateList.size() == 1 ) {
            updateConfirmedCallback.onConfirmed(true);
        }

    }

    @Override
    public EventList searchExecute() {
        EventList returnList = new EventList();
        return returnList;
    }
}
```
###### carelender\model\strings\DateFormats.java
``` java
    /**
     * Format key as YYYY D d EEE given date.
     * YYYY and D are used to sort the keys by date.
     * 
     * YYYY is the year of the event.
     * D is the day in the year.
     * d is the day in the month.
     * EEE is the day of the week.
     * 
     * @param date
     * 		Date to format as key.
     * @return
     * 		Key to use in taskDisplay
     */
    public static String FORMAT_KEY (Date date) {
        if (date == null) {
            return "";
        }

        String day = DATE_FORMAT_DAY.format(date);
        String dayInYear = DAY_IN_YEAR.format(date);
        //If the day in the year is less than 3 digits, prepend with 0s, eg. 64 to 064
        //Necessary for radix sort of String keys in TreeMap to ensure order is preserved.
        int length = dayInYear.length();
        for (int i = 0; i < (3 - length); i++ ) {
            dayInYear = "0" + dayInYear;
        }
        String year = YEAR.format(date);
        
        //Concatenate all the parts of the key together.
        return (year + " " + dayInYear + " " + day);
    }
    
    /**
     * Get the number of minutes given a specific date.
     * Limited to the time on the day of the date, not total elapsed.
     *
     * @param date
     * @return
     *  	Number of minutes in the date.
     */
    public static double TIME_IN_MINUTES ( Date date ) {
        if ( date == null ) {
            return 0;
        }
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        int hours = calendar.get(Calendar.HOUR_OF_DAY);
        int minutes = calendar.get(Calendar.MINUTE);

        return ((hours * 60) + minutes);
    }

    /**
     * Add the given number of days to a date.
     *
     * @param date
     * @param days
     * @return
     * 		The new date after the amount of days.
     */
    public static Date ADD_DAYS ( Date date, int days )
    {
        if (date == null) {
            return null;
        }

        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.DATE, days);
        
        return calendar.getTime();
    }
}
```
###### carelender\test\DateFormatsTest.java
``` java
package carelender.test;

import static org.junit.Assert.*;

import java.util.Calendar;
import java.util.Date;

import org.junit.Test;

import carelender.model.strings.DateFormats;

public class DateFormatsTest {

    @Test
    public void testFormatKey() {
        Calendar calendar;
        Date date;
        String key;

        assertEquals("", DateFormats.FORMAT_KEY(null));

        /*
         * Test prepending 2 0s behind the day of the year(1).
         *
         * This is a boundary case for the partition where the
         * date provided is the smallest day of the year.
         *
         */
        calendar = Calendar.getInstance();
        calendar.set(2013, Calendar.JANUARY, 1, 0, 0, 0);
        date = calendar.getTime();

        key = "2013 001 1 Tue";

        assertEquals(key, DateFormats.FORMAT_KEY(date));

        /*
         * Test prepending 1 0 behind the day of the year(26).
         */
        calendar = Calendar.getInstance();
        calendar.set(2013, Calendar.JANUARY, 26, 0, 0, 0);
        date = calendar.getTime();

        key = "2013 026 26 Sat";

        assertEquals(key, DateFormats.FORMAT_KEY(date));

        /*
         * Test prepending no 0s behind the day of the year(326).
         *
         * This is a boundary case for the partition where the
         * date provided is a 3-digit day of the year.
         *
         */
        calendar = Calendar.getInstance();
        calendar.set(2013, Calendar.NOVEMBER, 22, 0, 0, 0);
        date = calendar.getTime();

        key = "2013 326 22 Fri";

        assertEquals(key, DateFormats.FORMAT_KEY(date));
    }
}
```
###### carelender\test\SearchTest.java
``` java
package carelender.test;

import static org.junit.Assert.*;

import java.util.Date;
import java.util.HashMap;

import org.junit.Test;

import carelender.controller.Search;
import carelender.model.data.Event;
import carelender.model.data.QueryList;;

public class SearchTest{

    @Test
    public void testHasMethods() {
        HashMap<QueryList.SearchParam, Object> params = new HashMap<QueryList.SearchParam, Object>();

        /*
         * This is a boundary case for the partition where the
         * parameters list does not contain the desired parameter.
         */
        params.clear();
        assertFalse(Search.hasDateRange(params));
        /*
         * This is a boundary case for the partition where the
         * parameters list does contain the desired parameter.
         */
        params.put(QueryList.SearchParam.DATE_END, new Date());
        params.put(QueryList.SearchParam.DATE_START, new Date());
        assertTrue(Search.hasDateRange(params));

        params.clear();
        assertFalse(Search.hasStartDate(params));
        params.put(QueryList.SearchParam.DATE_START, new Date());
        assertTrue(Search.hasStartDate(params));

        params.clear();
        assertFalse(Search.hasEndDate(params));
        params.put(QueryList.SearchParam.DATE_END, new Date());
        assertTrue(Search.hasEndDate(params));

        params.clear();
        assertFalse(Search.hasNameContains(params));
        params.put(QueryList.SearchParam.NAME_CONTAINS, "name");
        assertTrue(Search.hasNameContains(params));

        params.clear();
        assertFalse(Search.hasNameExact(params));
        params.put(QueryList.SearchParam.NAME_EXACT, "match me exactly");
        assertTrue(Search.hasNameExact(params));
    }

    @Test
    public void testIsMethods() {
        HashMap<QueryList.SearchParam, Object> params = new HashMap<QueryList.SearchParam, Object>();
        Event event = new Event ( 0, "", null, null );

        event.setName("exact matching");
        /*
         * This is a boundary case for the partition where the
         * parameters list does contain the desired parameter.
         */
        assertFalse(Search.isEventNameExact(event, "not exact matching"));
        /*
         * This is a boundary case for the partition where the
         * parameters list does contain the desired parameter.
         */
        assertTrue(Search.isEventNameExact(event, "exact matching"));

        event.setName("jillian's birthday party");
        assertFalse(Search.isEventNameMatch(event, "birthday bash"));
        assertTrue(Search.isEventNameMatch(event, "birthday party"));
    }
}
```
###### carelender\view\gui\components\DateRangeRenderer.java
``` java
package carelender.view.gui.components;

import carelender.model.data.DateRange;
import carelender.model.strings.AppColours;
import carelender.model.strings.DateFormats;
import carelender.model.strings.FontLoader;
import javafx.geometry.VPos;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;

import java.util.Calendar;

/**
 * This class contains methods to render a date range.
 */
public class DateRangeRenderer {
    private static final double STRIKEOUT_HEIGHT = 2;
    
    private static final String DATETEXT_NOTIME_START = "Starts";
    private static final String DATETEXT_NOTIME_END = "Ends";

    private double xPaddingRatio;
    private double yPaddingRatio;

    private double timeTextWidthRatio;
    private double timeTextHeightRatio;
    private double dateTextHeightRatio;
    private double connectorWidthRatio;

    private String timeStart;
    private String timeEnd;
    private String dateStart;
    private String dateEnd;
    
    private boolean strikeout;

    public DateRangeRenderer() {
        this.timeStart = "";
        this.timeEnd = "";
        this.dateStart = "";
        this.dateEnd = "";
        
        this.strikeout = false;
    }
    
    /**
     * Set the dimensions for the date range render.
     * Padding ratios are with respect to the dimensions of the elements they pad.
     * 		e.g. Padding for dateText is yPadRatio * dateTextHeight
     * Ratio for dateTextHeight and connecterWidth is with respect to height of timeText.
     * Ratio for timeText are with respect to width and height of window.
     * 
     * @param xPadRatio
     * 		With respect to the dimensions of individual elements.
     * @param yPadRatio
     * 		With respect to the dimensions of individual elements.
     * @param timeTextWidthRatio
     * @param timeTextHeightRatio
     * @param dateTextHeightRatio
     * 		With respect to height of timeText.
     * @param connectorWidthRatio
     * 		With respect to height of timeText.
     * @param dateRange
     */
    public void setParams (double xPadRatio, double yPadRatio,
                           double timeTextWidthRatio, double timeTextHeightRatio, double dateTextHeightRatio,
                           double connectorWidthRatio, DateRange dateRange) {
        this.xPaddingRatio = xPadRatio;
        this.yPaddingRatio = yPadRatio;

        this.timeTextWidthRatio = timeTextWidthRatio;
        this.timeTextHeightRatio = timeTextHeightRatio;
        
        this.dateTextHeightRatio = dateTextHeightRatio;
        
        this.connectorWidthRatio = connectorWidthRatio;

        //Set the content for the date ranges.
        if ( dateRange != null ) {
            if ( dateRange.hasTime() ) {
                //Check if the start and date are in the same year.
                Calendar start = Calendar.getInstance();
                start.setTime(dateRange.getStart());
                Calendar end = Calendar.getInstance();
                end.setTime(dateRange.getEnd());
                boolean sameYear = start.get(Calendar.YEAR) == end.get(Calendar.YEAR);

                //Show only a single date when start and end are exactly the same date.
                if ( dateRange.getStart().equals(dateRange.getEnd()) ) {
                    this.timeStart = DateFormats.TIME_FORMAT.format(dateRange.getStart());

                    this.dateStart = DateFormats.DATE_FORMAT_MONTH.format(dateRange.getStart());
                } else {
                    this.timeStart = DateFormats.TIME_FORMAT.format(dateRange.getStart());
                    this.timeEnd = DateFormats.TIME_FORMAT.format(dateRange.getEnd());

                    //Show the year if the years are different between the dates.
                    if ( sameYear ) {
                        this.dateStart = DateFormats.DATE_FORMAT_MONTH.format(dateRange.getStart());
                        this.dateEnd = DateFormats.DATE_FORMAT_MONTH.format(dateRange.getEnd());
                    } else {
                        this.dateStart = DateFormats.DATE_FORMAT_YEAR.format(dateRange.getStart());
                        this.dateEnd = DateFormats.DATE_FORMAT_YEAR.format(dateRange.getEnd());
                    }
                }
            } else {
                if ( dateRange.getStart().equals(dateRange.getEnd()) ) {
                    this.timeStart = DateFormats.DATE_FORMAT_MONTH.format(dateRange.getStart());
                    this.dateStart = DATETEXT_NOTIME_START;
                } else {
                    this.dateStart = DATETEXT_NOTIME_START;
                    this.dateEnd = DATETEXT_NOTIME_END;
                    Calendar start = Calendar.getInstance();
                    start.setTime(dateRange.getStart());
                    Calendar end = Calendar.getInstance();
                    end.setTime(dateRange.getEnd());
                    boolean sameYear = start.get(Calendar.YEAR) == end.get(Calendar.YEAR);
                    
                    //For events without time show the date in place of the time.
                    if ( sameYear ) {
                        this.timeStart = DateFormats.DATE_FORMAT_MONTH.format(dateRange.getStart());
                        this.timeEnd = DateFormats.DATE_FORMAT_MONTH.format(dateRange.getEnd());
                    } else {
                        this.timeStart = DateFormats.DATE_FORMAT_YEAR.format(dateRange.getStart());
                        this.timeEnd = DateFormats.DATE_FORMAT_YEAR.format(dateRange.getEnd());
                    }
                }
            }
        }
    }
    
    public double getTimeTextHeightRatio () {
        return this.timeTextHeightRatio;
    }
    
    public double getDateTextHeightRatio() {
        return this.dateTextHeightRatio;
    }
    
    public void strikeout () {
        this.strikeout = !this.strikeout;
    }
    
    public void draw (GraphicsContext gc, double x, double y, double width, double height, 
                        Color backgroundColour, Color textColour) {
        if (gc == null) {
            System.out.println("Error");
        } else {
            double xCurrent = x;
            double yCurrent = y;

            double timeWidth = timeTextWidthRatio * width;
            double timeHeight = timeTextHeightRatio * height;

            double dateHeight = dateTextHeightRatio * timeHeight;

            double connectorWidth = connectorWidthRatio * timeWidth;
            double strikeoutWidth = timeWidth;

            Font dateFont = FontLoader.load( dateHeight - (yPaddingRatio * dateHeight * 2));
            Font timeFont = FontLoader.load( timeHeight - (yPaddingRatio * timeHeight * 2));

            if ( !this.dateStart.equals("") ) {
                renderDate(gc, xCurrent, yCurrent, backgroundColour, dateFont, dateStart);
            }

            xCurrent += (timeWidth + connectorWidth);
            if ( !this.dateEnd.equals("") ) {
                renderDate(gc, xCurrent, yCurrent, backgroundColour, dateFont, dateEnd);
            }

            xCurrent = x;
            yCurrent += dateHeight;
            if ( !this.timeStart.equals("") ) {
                renderTime(gc, xCurrent, yCurrent, timeWidth, timeHeight,
                            backgroundColour, textColour, timeFont, timeStart);
            }

            xCurrent += timeWidth;
            if ( !this.timeEnd.equals("") ) {
                renderConnector(gc, xCurrent, yCurrent, connectorWidth, timeHeight, backgroundColour);

                xCurrent += connectorWidth;

                renderTime(gc, xCurrent, yCurrent, timeWidth, timeHeight,
                        backgroundColour, textColour, timeFont, timeEnd);
                
                strikeoutWidth += (timeWidth + connectorWidth);
            }

            xCurrent = x;
            yCurrent += (timeHeight * 0.5) - (DateRangeRenderer.STRIKEOUT_HEIGHT * 0.5);
            if ( this.strikeout ) {
                renderStrikeout(gc, xCurrent, yCurrent, strikeoutWidth,
                                DateRangeRenderer.STRIKEOUT_HEIGHT, AppColours.important);
            }
        }
    }
    
    /**
     * Render the date for a given date range.
     * 
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param colour
     * @param dateFont
     * @param text
     * 		Date to be displayed.
     */
    private void renderDate (GraphicsContext gc, double xCurrent, double yCurrent,
                                Color colour, Font dateFont, String text) {
        gc.setFill(colour);
        gc.setTextAlign(TextAlignment.LEFT);
        gc.setFont(dateFont);
        gc.setTextBaseline(VPos.TOP);

        gc.fillText ( text, xCurrent, yCurrent );
    }
    
    /**
     * Render the time for a given date range.
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param height
     * @param backgroundColour
     * @param textColour
     * @param timeFont
     * @param text
     */
    private void renderTime (GraphicsContext gc, double xCurrent, double yCurrent,
                                double width, double height,
                                Color backgroundColour, Color textColour, Font timeFont, String text) {
        gc.setFill(backgroundColour);
        gc.fillRect(xCurrent, yCurrent, width, height);

        gc.setFill(textColour);
        gc.setTextAlign(TextAlignment.LEFT);
        gc.setFont(timeFont);
        gc.setTextBaseline(VPos.TOP);

        gc.fillText ( text, xCurrent + (xPaddingRatio * width), yCurrent );
    }
    
    /**
     * Render the connector between the start and end date of a dateRange.
     * 
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param height
     * 		Height of the timeText.
     * @param backgroundColour
     */
    private void renderConnector (GraphicsContext gc, double xCurrent, double yCurrent,
                                    double width, double height, Color backgroundColour) {
        gc.setFill(backgroundColour);
        gc.fillPolygon(new double[]{xCurrent - 1, xCurrent + width + 1, xCurrent - 1},
                        new double[]{yCurrent, yCurrent + (height * 0.5), yCurrent + height}, 3);
    }
    
    /**
     * Render the strikeout to be displayed when dateRanges have passed.
     * 
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param height
     * @param backgroundColour
     */
    private void renderStrikeout (GraphicsContext gc, double xCurrent, double yCurrent,
                                    double width, double height, Color backgroundColour) {
        gc.setFill(backgroundColour);
        gc.fillRect(xCurrent, yCurrent, width, height);
    }
}
```
###### carelender\view\gui\components\TaskBarRenderer.java
``` java
package carelender.view.gui.components;

import carelender.model.data.DateRange;
import carelender.model.data.Event;
import carelender.model.strings.AppColours;
import carelender.model.strings.FontLoader;
import javafx.geometry.VPos;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;

import java.util.ArrayList;
import java.util.Date;

/**
 * This class contains methods to render each task bar in the task view.
 */
public class TaskBarRenderer {
    private static final double FADEOUT_ALPHA = 0.3;
    private static final double DEFAULT_ALPHA = 1;

    private static final double NAME_WIDTH_RATIO = 0.8;
    private static final double NAME_Y_PADDING = 0;
    private static final double NAME_X_PADDING = 0;
    private static final double NAME_LINE_PADDING_RATIO = 0;
    private static final double NAME_FONT_WIDTH_RATIO = 0.6;

    private static final double CATEGORY_WIDTH_RATIO = 0.2;

    private static final double DATERENDERER_X_PADDING_RATIO = 0.1;
    private static final double DATERENDERER_Y_PADDING_RATIO = 0.1;
    private static final double DATERENDERER_TIMETEXT_WIDTH_RATIO = 0.2;
    private static final double DATERENDERER_TIMETEXT_HEIGHT_RATIO = 0.4;
    private static final double DATERENDERER_DATETEXT_HEIGHT_RATIO = 0.7;
    private static final double DATERENDERER_CONNECTOR_WIDTH_RATIO = 0.3;

    private ArrayList<DateRangeRenderer> dateRangeRendererList;
    private TextRenderer nameText;
    private Event event;
    
    private double xPadding;
    private double yPadding;
    private double nameTextRatio;
    
    private boolean strikeout;

    public TaskBarRenderer() {
        this.nameText = new TextRenderer();
        
        this.dateRangeRendererList = new ArrayList<>();
        this.strikeout = false;
    }

    /**
     * Set the content of the task bar according to the given event.
     * 
     * @param event
     * 		Event the task bar is to display information about.
     */
    public void setContent (Event event) {
        this.event = event;
        this.strikeout = event.getCompleted();

        dateRangeRendererList.clear();
        //Get the current time.
        Date currentDate = new Date();
        DateRange [] dateRanges = event.getDateRange();
        if ( dateRanges != null ) {
            for (DateRange date : dateRanges) {
                DateRangeRenderer dateRangeRenderer = new DateRangeRenderer();
                //Check if the date range is still relevant as of current time.
                if (date.getStart().after(currentDate) || date.getEnd().after(currentDate)) {
                    dateRangeRenderer.setParams(DATERENDERER_X_PADDING_RATIO, DATERENDERER_Y_PADDING_RATIO,
                                                DATERENDERER_TIMETEXT_WIDTH_RATIO, DATERENDERER_TIMETEXT_HEIGHT_RATIO,
                                                DATERENDERER_DATETEXT_HEIGHT_RATIO, DATERENDERER_CONNECTOR_WIDTH_RATIO, date);
                    dateRangeRendererList.add(dateRangeRenderer);
                } else {
                    dateRangeRenderer.setParams(DATERENDERER_X_PADDING_RATIO, DATERENDERER_Y_PADDING_RATIO,
                                                DATERENDERER_TIMETEXT_WIDTH_RATIO, DATERENDERER_TIMETEXT_HEIGHT_RATIO,
                                                DATERENDERER_DATETEXT_HEIGHT_RATIO, DATERENDERER_CONNECTOR_WIDTH_RATIO, date);
                    //Strike out the date range if it has already passed.
                    dateRangeRenderer.strikeout();
                    dateRangeRendererList.add(dateRangeRenderer);
                }
            }
        }
    }

    /**
     * Set the parameters required for drawing the task bar.
     * Ratios are with respect to the width of the task view.
     * 
     * @param xPad
     * @param yPad
     * @param nameTextRatio
     */
    public void setParams (double xPad, double yPad, double nameTextRatio) {
        this.xPadding = xPad;
        this.yPadding = yPad;

        this.nameTextRatio = nameTextRatio;
    }
    
    public void strikeout () {
        this.strikeout = !this.strikeout;
    }

    /**
     * Calculate the height of the task bar.
     * The actual height of the task bar is calculated with respect to the given height.
     * DateRangeRenderer heights are calculated and summed.
     * Padding is included.
     * 
     * @param height
     * 		The initial height of the task bar.
     * @return
     * 		The height of the task bar with date ranges included.
     */
    public double getHeight (double height) {
        double toReturnHeight = 0;
        //Add the height of the name of the task bar.
        toReturnHeight += (height * nameTextRatio);
        toReturnHeight += yPadding;
        //Add the height of each date range displayed.
        for (DateRangeRenderer dateRangeRenderer : dateRangeRendererList) {
            //Add height of the time display within the DateRangeRenderer.
            toReturnHeight += (dateRangeRenderer.getTimeTextHeightRatio() * height);
            //Add height of the date display within the DateRangeRenderer.
            toReturnHeight += dateRangeRenderer.getDateTextHeightRatio() * (dateRangeRenderer.getTimeTextHeightRatio() * height);
            toReturnHeight += yPadding;
        }
        toReturnHeight += yPadding;
        return toReturnHeight;
    }
    
    /**
     * Render the task bar.
     * 
     * @param gc
     * @param x
     * @param y
     * @param width
     * @param height
     * @param backgroundColour
     * @param textColour
     * @param ellipsize
     * 		Set the type of text renderer to ellipsis or wrap overflow.
     */
    public void draw (GraphicsContext gc, double x, double y,
                        double width, double height,
                        Color backgroundColour, Color textColour, boolean ellipsize) {
        if (gc == null) {
            System.out.println("Error");
        } else {
            double xCurrent = x;
            double yCurrent = y;
            
            Font font = FontLoader.load(height * nameTextRatio);

            if ( strikeout ) {
                gc.setGlobalAlpha(FADEOUT_ALPHA);
            } else {
                gc.setGlobalAlpha(DEFAULT_ALPHA);
            }

            gc.setFill(backgroundColour);
            gc.fillRect(xCurrent, yCurrent, width, getHeight(height));
            
            xCurrent += xPadding;
            yCurrent += yPadding;
            
            renderName(gc, xCurrent, yCurrent, width, height,
                        backgroundColour, textColour, font, ellipsize);
            
            if (event.getCategory() != null) {
                renderCategory(gc, xCurrent, yCurrent, width, height,
                                font, event.getCategory());
            }

            yCurrent += (nameText.getTextHeight() + yPadding);
            for (DateRangeRenderer dateRangeRenderer : dateRangeRendererList) {
                dateRangeRenderer.draw(gc, xCurrent, yCurrent, width, height,
                                        AppColours.panelBackground, backgroundColour);

                yCurrent += dateRangeRenderer.getTimeTextHeightRatio() * height;
                yCurrent += dateRangeRenderer.getDateTextHeightRatio() * (dateRangeRenderer.getTimeTextHeightRatio() * height);
                yCurrent += yPadding;
            }
            gc.setGlobalAlpha(DEFAULT_ALPHA);
        }
    }
    
    /**
     * Render the name of the task bar.
     * 
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param height
     * @param backgroundColour
     * @param textColour
     * @param font
     * @param ellipsize
     * 		Set the type of text renderer to ellipsis or wrap overflow.
     */
    private void renderName (GraphicsContext gc, double xCurrent, double yCurrent,
                                double width, double height,
                                Color backgroundColour, Color textColour,
                                Font font, boolean ellipsize ) {
        nameText.setParams(gc, xCurrent, yCurrent,
                            width * NAME_WIDTH_RATIO, font.getSize(),
                            NAME_X_PADDING, NAME_Y_PADDING, font, NAME_LINE_PADDING_RATIO);
        nameText.clearText();
        if (ellipsize) {
            nameText.addTextEllipsis(event.getName());
        } else {
            nameText.addText(event.getName());
        }

        nameText.drawText(backgroundColour, textColour);
    }
    
    /**
     * Render the category display on the task bar.
     * Colour of the category is determined by the hashCode of the string.
     * Modulo of hashCode taken against the number of category colours for wrap-around.
     * 
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param height
     * @param font
     * @param category
     */
    private void renderCategory (GraphicsContext gc, double xCurrent, double yCurrent,
                                    double width, double height, Font font, String category) {
        int colourCode = Math.abs(category.hashCode());
        colourCode %= AppColours.NUM_CATEGORIES;

        gc.setFill(AppColours.category[colourCode]);
        gc.fillRect(xCurrent + (width * NAME_WIDTH_RATIO) - (width * CATEGORY_WIDTH_RATIO * 0.5),
                    yCurrent, (width * CATEGORY_WIDTH_RATIO), font.getSize());
    
        gc.setFill(AppColours.panelBackground);
        gc.setTextAlign(TextAlignment.CENTER);
        gc.setFont(font);
        gc.setTextBaseline(VPos.CENTER);

        gc.fillText(category, xCurrent + (width * NAME_WIDTH_RATIO),
                    yCurrent + (font.getSize() * 0.5));
    }
}
```
###### carelender\view\gui\components\TaskRenderer.java
``` java
package carelender.view.gui.components;

import carelender.model.strings.AppColours;
import carelender.model.strings.DateFormats;
import carelender.model.strings.FontLoader;
import carelender.view.gui.CanvasRenderer;
import javafx.geometry.VPos;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;

import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.Collections;
import java.util.Comparator;

import carelender.model.data.Event;
import carelender.model.data.EventList;

/**
 * This class contains methods to render the task view.
 */
public class TaskRenderer extends CanvasRenderer {
    //Ratios used to ensure sizes scale with the window height and width.
    private static final double TASKBAR_NAME_RATIO = 0.4;
    private static final double DIVISOR_HEIGHT_RATIO = 0.5;
    private static final double SCROLLPOINTER_HEIGHT_RATIO = 0.04;
    private static final double SCROLLPOINTER_WIDTH_RATIO = 0.02;

    private static final double INDEX_FONTSIZE_RATIO = 0.5;
    private static final double DATE_FONTSIZE_RATIO = 0.5;
    private static final double SCROLLPOINTER_FONTSIZE_RATIO = 0.02;

    private static final String FLOATING_TASK_KEY = "F";
    private static final String SCROLLPOINTER_PAGEUP = "Pg Up";
    private static final String SCROLLPOINTER_PAGEDOWN = "Pg Dn";

    private Map<String, EventList> taskDisplay;
    private Comparator<Event> eventComparator;
    private TaskBarRenderer taskBarRender;
    private int totalTasks;
    private int displayStart;

    private double xPadding;
    private double yPadding;
    private double dateWidthRatio;
    private double dateHeightRatio;
    private double taskWidthRatio;
    private double taskHeightRatio;

    public TaskRenderer () {
        this.taskBarRender = new TaskBarRenderer();
        this.taskDisplay = new TreeMap<>();
        
        this.totalTasks = 0;
        this.displayStart = 0;

        //Comparator to compare events by date range.
        this.eventComparator = (Event eventAgainst, Event eventTo) -> {
            if ( eventAgainst.getEarliestDate() == null || eventTo.getEarliestDate() == null ) {
                return 0;
            }

            if (eventAgainst.getEarliestDate().before(eventTo.getEarliestDate())) {
                return -1;
            } else if (eventAgainst.getEarliestDate().after(eventTo.getEarliestDate())) {
                return 1;
            }
            return 0;
        };
    }
    
    /**
     * Set the ratios for the task bars and date display, along with padding.
     * Ratios are with respect to the width and height of the window respectively.
     * 
     * @param xPad
     * @param yPad
     * @param taskWidthRatio
     * @param taskHeightRatio
     * @param dateWidthRatio
     * @param dateHeightRatio
     */
    public void setParams (double xPad, double yPad,
                           double taskWidthRatio, double taskHeightRatio,
                           double dateWidthRatio, double dateHeightRatio) {

        this.taskWidthRatio = taskWidthRatio;
        this.taskHeightRatio = taskHeightRatio;
        this.dateWidthRatio = dateWidthRatio;
        this.dateHeightRatio = dateHeightRatio;

        this.xPadding = xPad;
        this.yPadding = yPad;
        
    }

    @Override
    public void draw(GraphicsContext gc, double x, double y, double width, double height) {
        super.draw(gc, x, y, width, height);
        
        taskBarRender.setParams(xPadding, yPadding, TASKBAR_NAME_RATIO);
        
        gc.setFill(AppColours.panelBackground);
        gc.fillRect(x, y, width, height);
        
        renderTasks (gc, x, y, width, height);
    }
    
    /**
     * Shifts the scroll window up for the task renderer.
     * Redraws canvas on each call.
     */
    public void scrollDown () {
        if (displayStart > 0) {
            displayStart--;
        }
        redraw();
    }
    
    /**
     * Shifts the scroll window down for the task renderer.
     * Redraws canvas on each call.
     */
    public void scrollUp () {
        if (displayStart < totalTasks - 1) {
            displayStart++;
        }
        redraw();
    }

    /**
     * Remove events in taskDisplay map and sets the scroll window back to default.
     */
    public void clearEvents () {
        taskDisplay.clear();
        totalTasks = 0;
        displayStart = 0;
    }
    
    /**
     * Concatenates content of each EventList within taskDisplay TreeMap into one EventList.
     * 
     * @return
     * 		EventList with all events in the taskDisplay.
     */
    public EventList getDisplayList () {
        List<Event> concatList = new EventList();
        for (EventList events : taskDisplay.values()) {
            concatList.addAll(events);
        }
        return (EventList)concatList;
    }

    /**
     * Adds all events in EventList to taskDisplay, with the day of the event as keys
     * Events stretching over several days are added into several key-value pairs in the taskDislay
     * 
     * @param toDisplay
     * 		EventList containing events to be added to taskDisplay
     */
    public void addEvents (EventList toDisplay) {
        for ( Event event : toDisplay ) {
            Date currentDay = event.getEarliestDateFromNow();
            //If there is no earliest date range from the current time
            //Find the earliest date of all the date ranges.
            if ( currentDay == null ) {
                currentDay = event.getEarliestDate();
            }
            
            if ( currentDay == null ) { //Event is a floating task.
                addEventToMap(FLOATING_TASK_KEY, event);
            } else {
                //Concatenate all the parts of the key together.
                addEventToMap(DateFormats.FORMAT_KEY(currentDay), event);
            }
            totalTasks++;
        }
        
        for (EventList events : taskDisplay.values()) {
            Collections.sort(events, eventComparator);
        }
    }

    /**
     * Add an event to taskDisplay with key.
     * If the key already exists in taskDisplay add it to the EventList associated.
     * Otherwise, create a new EventList containing the event to add associated with the key.
     * 
     * @param key
     * 		The day of the event is used as the key as YYYY D d EEE
     * @param event
     * 		The event to add.
     */
    private void addEventToMap (String key, Event event) {
        if (taskDisplay.containsKey(key)) {
            if (!taskDisplay.get(key).contains(event)) {
                taskDisplay.get(key).add(event);
            }
        } else {
            EventList tasksOnDay = new EventList();
            tasksOnDay.add(event);
            taskDisplay.put(key, tasksOnDay);
        }
    }
    
    /**
     * Render the task bars.
     * 
     * @param gc
     * @param x
     * @param y
     * @param width
     * @param height
     */
    private void renderTasks (GraphicsContext gc, double x, double y, double width, double height) {
        double xCurrent = x + xPadding;
        double yCurrent = y + yPadding;

        double dateBarWidth = width * dateWidthRatio;
        double dateBarHeight = height * dateHeightRatio;
        
        double taskBarWidth = width * taskWidthRatio;
        double taskBarHeight = height * taskHeightRatio;
        
        Font dateFont = FontLoader.load(dateBarHeight * DATE_FONTSIZE_RATIO);
        Font indexFont = FontLoader.load(dateBarHeight * INDEX_FONTSIZE_RATIO);
        Font scrollPointerFont = FontLoader.load(width * SCROLLPOINTER_FONTSIZE_RATIO);

        //Variables to keep track of scroll window.
        int currentTaskToDisplay = 0;
        //Available space in the task view window to draw task bars.
        double remainingHeight = this.height - (this.yPadding * 2);
        boolean showBottomArrow = false;
        //Variables for date display.
        double xPositionDate;
        double yPositionDate;
        boolean displayDate;
        
        //Indexing for events.
        //Used for update/delete/show commands.
        int index = 1;

        for ( Map.Entry<String, EventList> entry : this.taskDisplay.entrySet()) {
            String key = entry.getKey();
            EventList value = entry.getValue();

            if ( currentTaskToDisplay >= displayStart ) {
                renderDivisor(gc, xCurrent, yCurrent, width, yPadding);
                yCurrent += (yPadding * 1.5);
            }
            
            xPositionDate = xCurrent;
            yPositionDate = yCurrent;

            displayDate = false;
            for (Event event : value) {
                if ( currentTaskToDisplay >= displayStart ) {
                    taskBarRender.setContent(event);

                    if ( (remainingHeight - taskBarRender.getHeight(taskBarHeight)) >= 0 ) {
                        displayDate = true;

                        renderIndex(gc, xCurrent + dateBarWidth, yCurrent, indexFont, String.valueOf(index));

                        taskBarRender.draw(gc, xCurrent + dateBarWidth + xPadding, yCurrent,
                                                taskBarWidth, taskBarHeight, AppColours.tasklistRowBackground,
                                                AppColours.tasklistText, true);

                        yCurrent += (taskBarRender.getHeight(taskBarHeight) + yPadding);
                        remainingHeight -= (taskBarRender.getHeight(taskBarHeight) + (yPadding * 2));
                     } else {
                        //Task to add exceeds the remaining space in the window.
                        showBottomArrow = true;
                        break;
                    }
                }
                index++;
                currentTaskToDisplay++;
            }

            if ( displayDate ) {
                renderDate(gc, xPositionDate, yPositionDate, dateFont, key);
            }
            
            if ( showBottomArrow ) {
                //Prevent subsequent tasks from being printed within scroll window.
                break;
            }
        }
        
        if ( this.displayStart > 0 ) {
            xCurrent = x + width - (width * SCROLLPOINTER_HEIGHT_RATIO) - xPadding;
            yCurrent = y + yPadding;
            
            renderScrollPointerUp(gc, xCurrent, yCurrent, width, scrollPointerFont);
        }
        
        if ( showBottomArrow ) {
            xCurrent = x + width - (width * SCROLLPOINTER_HEIGHT_RATIO) - xPadding;
            yCurrent = y + height - (width * SCROLLPOINTER_HEIGHT_RATIO) - yPadding;
            
            renderScrollPointerDown(gc, xCurrent, yCurrent, width, scrollPointerFont);
        }
    }
    
    /**
     * Render the divisors between each day in task view.
     * 
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param height
     */
    private void renderDivisor (GraphicsContext gc, double xCurrent, double yCurrent, double width, double height) {
        gc.setFill (AppColours.tasklistRowBackground);
        gc.fillRect(xCurrent, yCurrent, width - (xPadding * 2), height * DIVISOR_HEIGHT_RATIO);
    }
    
    /**
     * Render the index for each task.
     * 
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param indexFont
     * @param index
     */
    private void renderIndex (GraphicsContext gc, double xCurrent, double yCurrent,
                                Font indexFont, String index) {
        gc.setFill(AppColours.primaryColour);
        gc.setTextAlign(TextAlignment.RIGHT);
        gc.setFont(indexFont);
        gc.setTextBaseline(VPos.TOP);

        gc.fillText(index, xCurrent, yCurrent);
    }
    
    /**
     * Render the date for each day in task view.
     * 
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param dateFont
     * @param key
     */
    private void renderDate (GraphicsContext gc, double xCurrent, double yCurrent,
                                Font dateFont, String key) {
        gc.setFill(AppColours.tasklistRowBackground);
        gc.setTextAlign(TextAlignment.LEFT);
        gc.setFont(dateFont);
        gc.setTextBaseline(VPos.TOP);

        String [] keyWords = key.split(" ");
        //Only display the day of month and day of week of the key.
        if ( keyWords.length > 2 ) {
            gc.fillText(keyWords[2], xCurrent, yCurrent);
            gc.fillText(keyWords[3], xCurrent, yCurrent + dateFont.getSize());
        }
    }
    
    /**
     * Render the scroll pointer for page up.
     * 
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param scrollPointerFont
     */
    private void renderScrollPointerUp (GraphicsContext gc, double xCurrent, double yCurrent,
                                        double width, Font scrollPointerFont) {
        gc.setFill (AppColours.important);
        gc.fillPolygon(new double[] {xCurrent, xCurrent + (width * SCROLLPOINTER_WIDTH_RATIO), xCurrent - (width * SCROLLPOINTER_WIDTH_RATIO)},
                        new double[] {yCurrent, yCurrent + (width * SCROLLPOINTER_HEIGHT_RATIO), yCurrent + (width * SCROLLPOINTER_HEIGHT_RATIO)}, 3);

        yCurrent += (width * SCROLLPOINTER_HEIGHT_RATIO);

        gc.setFill(AppColours.important);
        gc.setTextAlign(TextAlignment.CENTER);
        gc.setFont(scrollPointerFont);
        gc.setTextBaseline(VPos.TOP);
        gc.fillText(SCROLLPOINTER_PAGEUP, xCurrent, yCurrent);
    }
    
    /**
     * Render the scroll pointer for page down.
     * 
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param scrollPointerFont
     */
    private void renderScrollPointerDown (GraphicsContext gc, double xCurrent, double yCurrent,
                                            double width, Font scrollPointerFont) {
        gc.setFill (AppColours.important);
        gc.fillPolygon(new double[] {xCurrent, xCurrent + (width * SCROLLPOINTER_WIDTH_RATIO), xCurrent - (width * SCROLLPOINTER_WIDTH_RATIO)},
                        new double[] {yCurrent + (width * SCROLLPOINTER_HEIGHT_RATIO), yCurrent, yCurrent}, 3);

        gc.setFill(AppColours.important);
        gc.setTextAlign(TextAlignment.CENTER);
        gc.setFont(scrollPointerFont);
        gc.setTextBaseline(VPos.BOTTOM);
        gc.fillText(SCROLLPOINTER_PAGEDOWN, xCurrent, yCurrent);
    }
}
```
###### carelender\view\gui\components\TextRenderer.java
``` java
package carelender.view.gui.components;

import carelender.model.strings.AppColours;
import carelender.model.strings.FontLoader;
import javafx.geometry.VPos;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;

import java.util.ArrayList;

/**
 * This class contains methods to render wrapping text.
 */
public class TextRenderer {

    private ArrayList<String> textLines;
    private GraphicsContext gc;
    private Font font;
    
    private double xPosition;
    private double yPosition;

    private double width;
    private double height;

    private double xPadding;
    private double yPadding;

    private double charWidth;
    private double charHeight;
    private double lineSpace;

    private double charsPerLine;


    public TextRenderer() {
        this.gc = null;
        this.textLines = new ArrayList<>();
}

    public void setPosition ( double x, double y ) {
        this.xPosition = x;
        this.yPosition = y;
    }
    
    public void setParams ( GraphicsContext gc, double x, double y,
                            double w, double h, double xPad, double yPad,
                            Font font, double lineSpaceRatio ) {
        this.gc = gc;

        this.xPosition = x;
        this.yPosition = y;

        this.width = w;
        this.height = h;

        this.xPadding = xPad;
        this.yPadding = yPad;

        this.font = font;
        this.charHeight = this.font.getSize();
        this.charWidth = this.font.getSize() * FontLoader.FONT_WIDTH_RATIO;
        this.lineSpace = this.font.getSize() * lineSpaceRatio;

        this.charsPerLine = Math.floor ((this.width - (this.xPadding * 2)) / this.charWidth);
        clearText();
        gc.setTextAlign(TextAlignment.LEFT);
    }

```
###### carelender\view\gui\components\TextRenderer.java
``` java
    public void addText ( String textToAdd ) {
        if ( textToAdd == null ) {
            return;
        }
        if (this.gc == null) {
            System.out.println("Error");
        } else {
            double freeCharsOnLine = this.charsPerLine;
            String lineToAppendTo = "";

            String [] wordsToAdd = this.separateEndline(textToAdd).split(" ");
            //Check if there are already lines of text to append textToAdd to.
            if ( !this.textLines.isEmpty() ) {
                //Get the last line rendered to check if words can be appended on.
                lineToAppendTo = this.textLines.get(this.textLines.size() - 1);
                freeCharsOnLine -= lineToAppendTo.length();
            } else {
                this.textLines.add("");
            }

            for ( String wordToAdd : wordsToAdd ) {
                if ( wordToAdd.length() > 0 ) {
                    if ( wordToAdd.equals("\n") ) {
                        freeCharsOnLine = this.charsPerLine;
                        lineToAppendTo = "";
                        this.textLines.add(lineToAppendTo);
                    } else if ( wordToAdd.length() <= freeCharsOnLine ) {
                        lineToAppendTo += (wordToAdd + " ");
                        freeCharsOnLine = this.charsPerLine - lineToAppendTo.length();
                        this.textLines.set(this.textLines.size() - 1, lineToAppendTo);
                    } else {
                        freeCharsOnLine = this.charsPerLine;
                        lineToAppendTo = wordToAdd + " ";
                        this.textLines.add(lineToAppendTo);
                    }
                }
            }
        }
    }

    public void clearText() {
        if (this.gc == null) {
            System.out.println("Error");
        } else {
            this.textLines.clear();
        }
    }

    public void drawText ( GraphicsContext gc, String background, String text ) {
        if (gc == null) {
            System.out.println("Error drawing text.");
        } else {
            double xCurrent = this.xPosition + this.xPadding;
            double yCurrent = this.yPosition + (this.yPadding + this.charHeight);

            gc.setFill(Color.web(background));
            gc.fillRect(this.xPosition, this.yPosition, this.width, this.height);

            for ( String lineToDraw : this.textLines ) {

                gc.setFill(Color.web(text));
                gc.setTextAlign(TextAlignment.LEFT);
                gc.setFont(this.font);
                gc.setTextBaseline(VPos.BOTTOM);

                gc.fillText ( lineToDraw, xCurrent, yCurrent );
                yCurrent += ( this.lineSpace + this.charHeight );
            }
        }
    }

    /**
     * Draws the text on screen with the parameters that have been set
     * @param background Color object representing the background colour
     * @param text Color object representing the text colour
     * @param boldFirst Number of lines to bold
     */
    public void drawText ( Color background, Color text, int boldFirst ) {
        if (this.gc == null) {
            System.out.println("Error");
        } else {
            double xCurrent = this.xPosition + this.xPadding;
            double yCurrent = this.yPosition + (this.yPadding + this.charHeight);

            gc.setFill(background);
            gc.fillRect(this.xPosition, this.yPosition, this.width, this.height);

            this.gc.setFill(text);
            for ( String lineToDraw : this.textLines ) {

                this.gc.setStroke(text);
                this.gc.setFill(text);
                this.gc.setTextAlign(TextAlignment.LEFT);
                this.gc.setFont(this.font);
                this.gc.setTextBaseline(VPos.BOTTOM);

                this.gc.fillText ( lineToDraw, xCurrent, yCurrent );
                if ( boldFirst > 0 ) {
                    this.gc.strokeText( lineToDraw, xCurrent, yCurrent );
                    boldFirst--;
                }
                yCurrent += ( this.lineSpace + this.charHeight );
            }
        }
    }
    /**
     * Draws the text on screen with the parameters that have been set
     * @param background Color object representing the background colour
     * @param text Color object representing the text colour
     */
    public void drawText ( Color background, Color text ) {
        if (this.gc == null) {
            System.out.println("Error");
        } else {
            drawText(background, text, 0);
        }
    }
    /**
     * Draws the text on screen with the parameters that have been set
     * @param background Color object representing the background colour
     */
    public void drawText (Color background) {
        if (this.gc == null) {
            System.out.println("Error");
        } else {
            drawText(background, AppColours.black);
        }
    }

    /**
     * Draws the text on screen with the parameters that have been set
     */
    public void drawText () {
        if (this.gc == null) {
            System.out.println("Error");
        } else {
            drawText(AppColours.primaryColour);
        }
    }
    
    /**
     * Get the height of the text box in pixels
     * @return Height of the text box
     */
    public double getTextHeight () {
        return (this.textLines.size() * this.charHeight)
                + (((this.textLines.size() - 1) <= 0 ? 0 : (this.textLines.size() - 1)) * this.lineSpace)
                + (this.yPadding * 2);
    }
    
    /**
     * Get the number of lines for the text
     * @return number of lines
     */
    public int getTextLines () {
        return this.textLines.size();
    }
    
    private String separateEndline ( String toParse ) {
        if ( toParse == null ) {
            return "";
        }
        if (this.gc == null) {
            System.out.println("Error");
            return "";
        } else {
            String toAppend = "";
            String toReturn = "";
            String [] stringSegment = toParse.split("\n", -1);
            for ( String segment : stringSegment ) {
                toReturn += (toAppend + segment);
                toAppend = " " + "\n" + " ";
            }
            return toReturn.equals("") ? toParse : toReturn;
        }
    }
}
```
###### carelender\view\gui\components\TimelineBarRenderer.java
``` java
package carelender.view.gui.components;

import carelender.model.strings.FontLoader;
import javafx.geometry.VPos;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;

/**
 * This class contains static methods to help to render the timeline view
 */
public class TimelineBarRenderer {
    public static final double MINUTES_IN_DAY = 1440;

    private static final double FADEOUT_ALPHA = 0.5;
    private static final double DEFAULT_ALPHA = 1;
    private static final double BAR_BORDER_SIZE = 5;
    private static final double FONT_SIZE_RATIO = 0.7;
    private static final double NO_RANGE_RATIO = 0.01;

    private double actualHeight;
    private double startTime;
    private double endTime;

    private String text;

    public TimelineBarRenderer() {
        this.actualHeight = 0;
        this.startTime = 0;
        this.endTime = 0;

        this.text = "";
    }

    /**
     * Set dimensions for timeline bar.
     *
     * @param startTime
     * @param endTime
     * @param content
     * 		Content to be displayed within the bar.
     */
    public void setParams ( double startTime, double endTime, String content) {
        this.startTime = startTime;
        this.endTime = endTime;

        this.text = content;
    }
    
    public void draw (GraphicsContext gc, Color backgroundColour, Color textColour,
                        double x, double y, double width, double height) {
        if (gc == null) {
            System.out.println("Error");
        } else {
            if ( this.endTime <= this.startTime ) {
                this.actualHeight = NO_RANGE_RATIO * height;
            } else {
                this.actualHeight = ((this.endTime - this.startTime) / MINUTES_IN_DAY) * height;
            }

            renderBar(gc, x, y, width, height, backgroundColour, textColour);
        }
    }

    /**
     * Render the timeline bar.
     * Text content is loaded in the center of the bar.
     *
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param height
     * @param backgroundColour
     * @param textColour
     */
    private void renderBar (GraphicsContext gc, double xCurrent, double yCurrent,
                            double width, double height,
                            Color backgroundColour, Color textColour) {
        gc.setFill(backgroundColour);
        gc.setGlobalAlpha(FADEOUT_ALPHA);
        gc.fillRect(xCurrent, yCurrent + ((startTime / MINUTES_IN_DAY) * height),
                    width, actualHeight);
        gc.fillRect(xCurrent + (BAR_BORDER_SIZE * 0.5), yCurrent + ((startTime / MINUTES_IN_DAY) * height) + (BAR_BORDER_SIZE * 0.5),
                width - BAR_BORDER_SIZE, actualHeight - BAR_BORDER_SIZE);
        gc.setGlobalAlpha(DEFAULT_ALPHA);

        Font font = FontLoader.load( width * FONT_SIZE_RATIO);
        gc.setFill(textColour);
        gc.setTextAlign(TextAlignment.CENTER);
        gc.setFont(font);
        gc.setTextBaseline(VPos.CENTER);

        gc.fillText (text, xCurrent + (width * 0.5),
                    yCurrent + ((startTime  / MINUTES_IN_DAY) * height) + (actualHeight * 0.5));
    }
}
```
###### carelender\view\gui\components\TimelineRenderer.java
``` java
package carelender.view.gui.components;

import carelender.model.strings.AppColours;
import carelender.model.strings.DateFormats;
import carelender.model.strings.FontLoader;
import carelender.view.gui.CanvasRenderer;
import javafx.geometry.VPos;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;

import java.util.ArrayList;
import java.util.Date;
import java.util.Map;
import java.util.TreeMap;
import carelender.model.data.DateRange;
import carelender.model.data.Event;
import carelender.model.data.EventList;

/**
 * This class contains methods to render the Timeline View
 */
public class TimelineRenderer extends CanvasRenderer {
    private static final double BAR_SIZE_MIN_RATIO = 0.5;

    private static final double FADEOUT_ALPHA = 0.3;
    private static final double DEFAULT_ALPHA = 1;

    private static final double FONT_SIZE_RATIO = 0.2;
    private static final double FONT_LARGE_SIZE_RATIO = 0.3;

    private static final double DIVISOR_SCALE_RATIO = 3;
    private static final double DIVISOR_LARGE_FONT_MOD = 6;

    private static final String FREE_BAR_TEXT_LINE1 = "Days";
    private static final String FREE_BAR_TEXT_LINE2 = "Free";

    private Map<String, ArrayList<TimelineBarRenderer>> weekDisplay;

    private double xPadding;
    private double yPadding;
    private double maxBarWidth;
    private double minBarWidth;
    private double labelWidth;
    
    private int displayStart;

    public TimelineRenderer() {
        this.weekDisplay = new TreeMap<>();
        this.displayStart = 0;
    }

    /**
     * Set up the dimensions for the timeline view.
     * 
     * @param xPad
     * @param yPad
     * @param maxBarWidth
     * 		Maximum size of each timeline bar.
     * @param labelWidth
     * 		Size to be reserved on the left for time labels.
     */
    public void setParams (double xPad, double yPad, double maxBarWidth, double labelWidth) {
        this.xPadding = xPad;
        this.yPadding = yPad;
        
        this.maxBarWidth = maxBarWidth;
        this.minBarWidth = maxBarWidth * BAR_SIZE_MIN_RATIO;
        this.labelWidth = labelWidth;
    }

    @Override
    public void draw (GraphicsContext gc, double x, double y, double width, double height) {
        super.draw(gc, x, y, width, height);

        Font font = FontLoader.load( labelWidth * FONT_SIZE_RATIO);
        Font fontLarge = FontLoader.load( labelWidth * FONT_LARGE_SIZE_RATIO);
        
        double xCurrent = x + this.labelWidth - this.xPadding;
        double yCurrent = y + (this.yPadding * 2) + font.getSize();

        gc.setFill(AppColours.panelBackground);
        gc.fillRect(x, y, width, height);

        renderDivisors(gc, xCurrent, yCurrent, width, height, font, fontLarge);

        xCurrent = x + this.labelWidth;
        renderBars(gc, xCurrent, yCurrent, width, height, font);
    }

    public void clear () {
        this.weekDisplay.clear();
        this.displayStart = 0;
    }
    
    public void scrollDown () {
        if ( this.displayStart > 0 ) {
            this.displayStart--;
        }
        redraw();
    }
    
    public void scrollUp () {
        if ( this.displayStart < this.weekDisplay.size() - 1 ) {
            this.displayStart++;
        }
        redraw();
    }

    /**
     * Add events from EventList to weekDisplay.
     * Events are indexed according to the order within toDisplay.
     * 
     * @param toDisplay
     * 		EventList to add to weekDisplay.
     */
    public void addEvents ( EventList toDisplay ) {
        int index = 1;
        for ( Event event : toDisplay ) {
            DateRange [] dateRange = event.getDateRange();
            if ( dateRange == null ) {
                continue;
            }
            for ( DateRange date : dateRange ) {
                String keyEnd = DateFormats.FORMAT_KEY(date.getEnd());
                String keyStart = DateFormats.FORMAT_KEY(date.getStart());
                //Event has a single date
                if (keyEnd.equals(keyStart)) {
                    addDateRangeToDisplay(keyStart, DateFormats.TIME_IN_MINUTES(date.getStart()),
                                            DateFormats.TIME_IN_MINUTES(date.getEnd()), String.valueOf(index));
                } else {
                    addDateRangeToDisplay(keyStart, DateFormats.TIME_IN_MINUTES(date.getStart()),
                                            TimelineBarRenderer.MINUTES_IN_DAY, String.valueOf(index));
                    Date currentDay = date.getStart();
                    //Event spans multiple days, add event to each day between start and end dates.
                    for ( int i = 0; i < date.getDaysBetween(); i++ ) {
                        currentDay = DateFormats.ADD_DAYS(currentDay, 1);
                        if (!(keyEnd.equals(DateFormats.FORMAT_KEY(currentDay)))) {
                            addDateRangeToDisplay(DateFormats.FORMAT_KEY(currentDay), 0,
                                                    TimelineBarRenderer.MINUTES_IN_DAY, String.valueOf(index));

                        }
                    }
                    this.addDateRangeToDisplay(keyEnd, 0, DateFormats.TIME_IN_MINUTES(date.getEnd()),
                                                String.valueOf(index));
                }
            }
            index++;
        }
    }

    /**
     * Render all the bars in the timeline.
     *
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param height
     * @param font
     */
    private void renderBars (GraphicsContext gc, double xCurrent, double yCurrent,
                                double width, double height, Font font) {
        int currentTaskToDisplay = 0;
        int lastDay = -1;
        int numberOfBars = getNumberOfBars();

        double barWidth = (width - (xPadding * (numberOfBars - 1)) - font.getSize()) / (numberOfBars);
        barWidth = (barWidth > maxBarWidth) ? maxBarWidth : barWidth;
        barWidth = (barWidth < minBarWidth) ? minBarWidth : barWidth;
        
        double usableWidth = width - labelWidth - (xPadding * 2);
        double usableHeight = height - labelWidth - (yPadding * 2);

        double remainingHeight = usableWidth;
        
        for ( Map.Entry<String, ArrayList<TimelineBarRenderer>> entry : weekDisplay.entrySet()) {
            if ( currentTaskToDisplay >= displayStart ) {
                String key = entry.getKey();
                ArrayList<TimelineBarRenderer> value = entry.getValue();

                gc.setTextAlign(TextAlignment.CENTER);
                gc.setFont(font);
                gc.setTextBaseline(VPos.CENTER);

                String [] keyWords = key.split(" ");
                if ( lastDay != -1 ) {
                    int freeDays = Integer.parseInt(keyWords[1]) - lastDay - 1;

                    if ( freeDays > 0 ) {
                        if ( (remainingHeight - barWidth - xPadding) >= 0 ) {
                            yCurrent = y + (yPadding * 2) + font.getSize();

                            renderFreeBar(gc, xCurrent, yCurrent, barWidth, usableHeight,
                                            font, String.valueOf(freeDays));

                            xCurrent += ( barWidth + xPadding );
                            remainingHeight -= (barWidth + xPadding);
                        } else {
                            break;
                        }
                    }
                }
                lastDay = Integer.parseInt(keyWords[1]);

                if ( (remainingHeight - barWidth - xPadding) >= 0 ) {
                    yCurrent = y + yPadding;

                    renderTimelineBar(gc, xCurrent, yCurrent, barWidth, usableHeight,
                                        font, keyWords[2], keyWords[3], value);

                    xCurrent += (barWidth + xPadding);
                    remainingHeight -= (barWidth + xPadding);
                } else {
                    break;
                }
            }
            currentTaskToDisplay++;
        }
    }

    /**
     * Render bars used to display free days between two days.
     *
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * 		Width of each bar.
     * @param height
     * 		Maximum height of each bar.
     * @param font
     * @param text
     * 		The number of days between the two days as a String.
     */
    private void renderFreeBar (GraphicsContext gc, double xCurrent, double yCurrent,
                                double width, double height, Font font, String text) {
        gc.setGlobalAlpha(FADEOUT_ALPHA);
        gc.setFill(AppColours.information);
        gc.fillRect(xCurrent, yCurrent + yPadding, width, height);
        gc.setGlobalAlpha(DEFAULT_ALPHA);

        gc.setFill(AppColours.tasklistRowBackground);
        yCurrent = y + yPadding + (height * 0.5);
        gc.fillText ( text, xCurrent + (width * 0.5), yCurrent );
        gc.fillText ( FREE_BAR_TEXT_LINE1, xCurrent + (width * 0.5), yCurrent + font.getSize() );
        gc.fillText ( FREE_BAR_TEXT_LINE2, xCurrent + (width * 0.5), yCurrent + (font.getSize() * 2) );
    }

    /**
     * Render the bars within a single day.
     * Each TimelineBarRenderer renders one block of time used by an event.
     *
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * 		Width of each bar.
     * @param height
     * 		Maximum height of each bar.
     * @param font
     * @param dateText
     * 		String in the form d, where d is the day in the month.
     * @param dayText
     * 		String in the form EEE, where E is the day of the week.
     * @param value
     * 		ArrayList of TimelineBarRenderer for each bar.
     */
    private void renderTimelineBar (GraphicsContext gc, double xCurrent, double yCurrent,
                                    double width, double height, Font font,
                                    String dateText, String dayText, ArrayList<TimelineBarRenderer> value) {
        gc.setTextAlign(TextAlignment.CENTER);
        gc.setFont(font);
        gc.setTextBaseline(VPos.CENTER);
        gc.setFill(AppColours.primaryColour);
        gc.fillText ( dateText, xCurrent + (width * 0.5), yCurrent );
        gc.fillText ( dayText, xCurrent + (width * 0.5), yCurrent + font.getSize() );
        
        yCurrent += yPadding + font.getSize();
        for (TimelineBarRenderer bar : value) {
            bar.draw(gc, AppColours.tasklistRowBackground, AppColours.primaryColour,
                        xCurrent, yCurrent + yPadding, width, height);
        }
    }

    /**
     * Render divisors used to demarcate the time of day.
     * 24 divisors are rendered for each hour of the day.
     *
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * @param height
     * @param font
     * @param fontLarge
     */
    private void renderDivisors (GraphicsContext gc, double xCurrent, double yCurrent,
                                    double width, double height, Font font, Font fontLarge) {
        double usableWidth = width - labelWidth - (xPadding * 2);
        double usableHeight = height - labelWidth - (yPadding * 2);
        double divisorWidth = (1 / TimelineBarRenderer.MINUTES_IN_DAY) * usableHeight;
        
        for (int i = 0; i <= 24; i++) {
            gc.setTextAlign(TextAlignment.RIGHT);
            gc.setTextBaseline(VPos.CENTER);
            //Every (DIVISOR_LARGE_FONT_MOD)th divisor is increased in size and opacity.
            if ( i % DIVISOR_LARGE_FONT_MOD == 0 ) {
                renderDivisor(gc, xCurrent, yCurrent, usableWidth, divisorWidth,
                        fontLarge, String.valueOf((i % 12) == 0 ? 12 : i % 12), DEFAULT_ALPHA);
            } else {
                renderDivisor(gc, xCurrent, yCurrent, usableWidth, divisorWidth,
                                font, String.valueOf((i % 12) == 0 ? 12 : i % 12), FADEOUT_ALPHA);
            }
            yCurrent += (60 / TimelineBarRenderer.MINUTES_IN_DAY) * usableHeight;
        }
    }

    /**
     * Render each divisor.
     *
     * @param gc
     * @param xCurrent
     * @param yCurrent
     * @param width
     * 		Width of the divisor.
     * @param height
     * 		Height of the divisor.
     * @param font
     * @param text
     *		Time of the day in hours, as a String.
     * @param alpha
     */
    private void renderDivisor (GraphicsContext gc, double xCurrent, double yCurrent,
                                double width, double height, Font font, String text, double alpha) {
        gc.setFont(font);
        gc.setGlobalAlpha(alpha);

        gc.setFill(AppColours.tasklistRowBackground);
        gc.fillText ( text, xCurrent, yCurrent + yPadding );

        gc.setFill(AppColours.primaryColour);
        gc.fillRect(xCurrent + xPadding, yCurrent + yPadding - (height * DIVISOR_SCALE_RATIO * 0.5),
                    width, height * DIVISOR_SCALE_RATIO);
        gc.setGlobalAlpha(DEFAULT_ALPHA);
    }

    /**
     * Return number of bars in total.
     * Bars used to display free days are counted as well.
     * 
     * @return
     * 		Number of bars.
     */
    private int getNumberOfBars () {
        int numberOfBars = weekDisplay.size();
        int lastDay = -1;
        //Count the number of bars to display in total, including bars used to show free days.
        for (Map.Entry<String, ArrayList<TimelineBarRenderer>> entry : weekDisplay.entrySet()) {
            String key = entry.getKey();
            String [] keyWords = key.split(" ");
            //Compare against previous day in the display.
            if ( lastDay != -1 ) {
                //Compare using the 2nd delimited chunk of the key, which is the day of the year.
                int freeDays = Integer.parseInt(keyWords[1]) - lastDay - 1;

                if ( freeDays > 0 ) {
                    numberOfBars += freeDays;
                }
            }
            lastDay = Integer.parseInt(keyWords[1]);
        }
        return numberOfBars;
    }

    /**
     * Add a date range to the weekDisplay.
     * Date ranges with the same key are stored in an ArrayList.
     * Each date range represents a bar on a single day.
     * 
     * @param key
     * @param startTime
     * @param endTime
     * @param content
     * 		The index of the event to be displayed on the bar.
     */
    private void addDateRangeToDisplay (String key, double startTime, double endTime, String content) {
        if (weekDisplay.containsKey(key)) {
            weekDisplay.get(key).add(createWeekBar(startTime, endTime, content));
        } else {
            ArrayList<TimelineBarRenderer> tasksOnDay = new ArrayList<TimelineBarRenderer>();
            tasksOnDay.add(createWeekBar(startTime, endTime, content));
            this.weekDisplay.put (key, tasksOnDay);
        }
    }

    /**
     * Create the TimelineBarRenderer object
     *
     * @param startTime
     * @param endTime
     * @param content
     * @return
     * 		The TimelineBarRenderer to be added to the weekDisplay.
     */
    private TimelineBarRenderer createWeekBar (double startTime, double endTime, String content) {
        TimelineBarRenderer bar = new TimelineBarRenderer();
        bar.setParams(startTime, endTime, content);
        return bar;
    }
}
```
