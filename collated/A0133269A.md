# A0133269A
###### carelender\controller\callbacks\OnConfirmedCallback.java
``` java
package carelender.controller.callbacks;

/**
 * Used for the confirmation input blocking state
 */
public interface OnConfirmedCallback {
    void onConfirmed (boolean confirmed);
}
```
###### carelender\controller\callbacks\OnEventSelectedCallback.java
``` java
package carelender.controller.callbacks;

import carelender.model.data.Event;

/**
 * Used for the event selection input blocking state
 */
public interface OnEventSelectedCallback {
    void onChosen(Event selected);
}
```
###### carelender\controller\callbacks\OnSelectedCallback.java
``` java
package carelender.controller.callbacks;


/**
 * Used for the option selection input blocking state
 */
public interface OnSelectedCallback {
    void onChosen(int selectedIndex);
}
```
###### carelender\controller\Controller.java
``` java
package carelender.controller;

import carelender.controller.callbacks.OnConfirmedCallback;
import carelender.controller.states.AppState;
import carelender.controller.states.BlockingStateController;
import carelender.controller.states.StateManager;
import carelender.model.AppSettings;
import carelender.model.AppSettings.SettingName;
import carelender.model.data.*;
import carelender.model.strings.FirstStartMessages;
import carelender.view.gui.UIController;
import carelender.view.gui.UIController.UIType;
import carelender.view.parser.DateTimeParser;
import carelender.view.parser.InputParser;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;

import java.util.*;

/**
 * Does all the logic of the application
 */
public class Controller {
    private static UIController UIController = null;
    private static StateManager stateManager;
    private static BlockingStateController blockingStateController;

    //Stores the messages to the user
    //private static ArrayList<String> messageList;
    //Stores the user's inputs
    private static ArrayList<String> commandList;
    private static int currentCommand;
    private static String incompleteInput;

    //Application state
    private static String userName;
    private static UIType defaultUIType;

    private static QueryList currentListQuery;
    private static TimerTask reminder;
    private static Timer timer;
    private static boolean isTimerRunning;

    public static void initialize() throws Exception {
        //messageList = new ArrayList<>();
        commandList = new ArrayList<>();
        stateManager = new StateManager();
        blockingStateController = new BlockingStateController();
        
        //Initialize timer for reminder

        isTimerRunning = false;
        userName = null;
        if(AppSettings.getInstance().getStringSetting(SettingName.USERNAME) != null){
            userName = AppSettings.getInstance().getStringSetting(SettingName.USERNAME);
            startTimer();
            System.out.println("Username: " + userName);
        } else {
            if ( !isTimerRunning ) {
                isTimerRunning = true;
                reminder = new ReminderCaller();
                timer = new Timer();
                timer.scheduleAtFixedRate(reminder, 100000, 5000);
            }
        }
        
        defaultUIType = AppSettings.getInstance().getUITypeSetting(SettingName.DEFAULT_UITYPE);
        System.out.println("Default UIType: " + defaultUIType);
        if (defaultUIType == null) {
            defaultUIType = UIType.TIMELINE;
        }
        
        currentCommand = 0;
    }
```
###### carelender\controller\Controller.java
``` java
    public static void initUserInterfaceController(UIController UIController) {
        Controller.UIController = UIController;

    }

    /**
     * The function that handles the key event from the UIController
     * @param keyEvent KeyEvent from JavaFX
     */
    public static void handleKeyEvent( final KeyEvent keyEvent ) {
        if (keyEvent.getEventType() == KeyEvent.KEY_PRESSED) {
            handleKeyPress(keyEvent.getCode(), keyEvent.isControlDown() || keyEvent.isShortcutDown());
        } else if (keyEvent.getEventType() == KeyEvent.KEY_RELEASED) {
            handleKeyRelease(keyEvent.getCode());
        }
    }

    /**
     * Called by UI while user is typing
     * @param userInput the incomplete user input
     */
    public static void processIncompleteInput(String userInput) {
        incompleteInput = userInput;
        if ( stateManager.getAppState() == AppState.DEFAULT && !blockingStateController.isBlocked() ) {
            StringBuilder stringBuilder = new StringBuilder();
            String [] autocompleteOptions = InputParser.getInstance().getAutocompleteOptions(userInput, stringBuilder);
            UIController.setAutocompleteOptions(autocompleteOptions, stringBuilder.toString());
        } else {
            UIController.setAutocompleteOptions(null, null);
        }

    }

    public static void showHelp() {
        blockingStateController.startPopup(InputParser.getInstance().showCommandList());
    }

    public static void printWelcomeMessage() {
        if ( stateManager.isState(AppState.FIRSTSTART) && userName == null ) {
            UIController.setAnnouncementMessage(FirstStartMessages.firstStart() + FirstStartMessages.askForName());
        } else {
            UIController.setAnnouncementMessage(FirstStartMessages.welcomeBack(userName));
            stateManager.changeState(AppState.DEFAULT);
        }
    }

    /**
     * Refreshes the list of events.
     * It is called after every query the user inputs
     */
    public static void refreshDisplay () {
        if ( currentListQuery == null) {
            currentListQuery = new QueryList();
            currentListQuery.addSearchParam(QueryList.SearchParam.DATE_START, DateTimeParser.getDate(0));
        }

        currentListQuery.controllerExecute();
        UIController.refreshOutputField();
    }

    /**
     * Processes the user input.
     * Called by the UIController class
     * @param userInput The user input string
     */
    public static void processCompleteInput(String userInput) {
        UIController.setAutocompleteOptions(null, null);
        userInput = userInput.trim();
        saveUserCommand(userInput);

        boolean blocked = blockingStateController.processBlockingState(userInput);

        if ( !blocked ) {
            switch ( stateManager.getAppState() ) {
                case FIRSTSTART:
                    stateFirstStart(userInput);
                    break;

                default:
                    stateDefault(userInput);
                    break;
            }
        }
    }

    /**
     * Prints a message to screen
     * @param message message to be displayed
     */
    public static void displayMessage ( String message ) {
        UIController.displayMessage(message);
    }

    public static void displayAnnouncement ( String message ) {
        UIController.setAnnouncementMessage(message);
    }

    public static void displayTasks (EventList events) {
        UIController.setTaskList(events);
    }


    public static void clearMessages () {
        UIController.clearMessageLog();
    }

    public static void setDisplayedList(EventList displayedList) {
        InputParser.getInstance().setDisplayedList(displayedList);
        UIController.setWeekEventList(displayedList);
    }

    public static BlockingStateController getBlockingStateController() {
        return blockingStateController;
    }


    public static UIType getDefaultUIType() {
        return defaultUIType;
    }

    public static UIController getUI() {
        return UIController;
    }

    /**
     * Handles the key press event
     * @param code JavaFX KeyCode
     * @param modifier Is control or command pressed
     */
    private static void handleKeyPress(KeyCode code, boolean modifier) {
        switch ( code ) {
            case ENTER:
                String text = UIController.getInputboxText();
                UIController.setInputboxText("");
                if ( UIController.getPendingAnnouncementMessage() != null ) {
                    stopTimer();
                    UIController.setAnnouncementMessage(UIController.getPendingAnnouncementMessage());
                    UIController.setPendingAnnouncementMessage(null);
                }
                processCompleteInput(text);
                break;
            case UP:
                if ( modifier ) {
                    UIController.taskViewScrollUp();
                } else {
                    processUpPress();
                }
                break;
            case DOWN:
                if ( modifier ) {
                    UIController.taskViewScrollDown();
                } else {
                    processDownPress();
                }
                break;
            case LEFT:
                if ( modifier ) {
                    UIController.timelineScrollLeft();
                }
                break;
            case RIGHT:
                if ( modifier ) {
                    UIController.timelineScrollRight();
                }
                break;
            case TAB:
                UIController.autocompleteSuggestion();
                break;
            case F1:
                UIController.setUI(UIType.TIMELINE);
                break;
            case F2:
                UIController.setUI(UIType.CALENDAR);
                break;
            case F3:
                UIController.setUI(UIType.FLOATING);
                break;
            case F4:
                UIController.setUI(UIType.SETTING);
                break;
            case PAGE_UP:
                UIController.taskViewScrollUp();
                break;
            case PAGE_DOWN:
                UIController.taskViewScrollDown();
                break;
            case HOME:
                UIController.timelineScrollLeft();
                break;
            case END:
                UIController.timelineScrollRight();
                break;
            case F12:
                startTimer();
                break;
            default:
                break;
        }
    }

    /**
     * Handles the key release event
     * @param code JavaFX KeyCode
     */
    private static void handleKeyRelease ( KeyCode code ) {
        switch ( code ) {
            case ENTER:
            case UP:
            case DOWN:
                break;
            case ALT:
                UIController.getAutomatedCommand(false);
                break;
            case CONTROL:
                UIController.getAutomatedCommand(true);
                break;
            default:
                processIncompleteInput(UIController.getInputboxText());
                break;
        }
    }

    /**
     * Called by UI when up key is pressed
     */
    private static void processUpPress() {
        if (currentCommand < commandList.size() - 1){
            currentCommand++;
        }
        showPreviousCommand();
    }

    /**
     * Called by UI when down key is pressed
     */
    private static void processDownPress() {
        if ( currentCommand >= 0 ) {
            currentCommand--;
        }
        showPreviousCommand();
    }

    /**
     * Shows any previous command based on the currentCommand variable
     */
    private static void showPreviousCommand() {
        if ( currentCommand == -1 ) { //Index -1 is an empty command
            UIController.setUserInput(incompleteInput);
        } else {
            int commandIndex = commandList.size() - currentCommand - 1;
            if (commandIndex < 0 || commandIndex >= commandList.size()) {
                return;
            }
            UIController.setUserInput(commandList.get(commandIndex));
        }
    }

    /**
     * Saves the user's command. Removes duplicates and empty commands
     * @param userInput User input to save
     */
    private static void saveUserCommand ( String userInput ) {
        if ( userInput.length() > 0 ) {
            int index = commandList.indexOf(userInput);
            if ( index >= 0 ) commandList.remove(index);
            commandList.add(userInput);
            currentCommand = -1;
        }
    }


    /**
     * The code that runs when the program is in the first start state
     * @param userInput User's input
     */
    private static void stateFirstStart ( String userInput ) {
        final OnConfirmedCallback confirmNameCallback = (boolean confirmed) -> {
                System.out.println("Confirmed: " + confirmed);
                if ( confirmed ) {
                    displayMessage(FirstStartMessages.confirmed(userName));
                    stateManager.changeState(AppState.DEFAULT);
                    AppSettings.getInstance().setStringSetting(SettingName.USERNAME, userInput);
                    refreshAnnoucementBox();
                    refreshDisplay();
                } else {
                    displayMessage(FirstStartMessages.askForNameAgain());
                    userName = null;
                }
            };
        userName = userInput;
        blockingStateController.startConfirmation(FirstStartMessages.confirmation(userName), confirmNameCallback);
    }

    /**
     * The code that runs when the program is in the default state
     * @param userInput User's input
     */
    private static void stateDefault(String userInput) {
        if ( userInput.length() == 0 ) {
            return;
        }
        Controller.clearMessages();
        QueryBase query = InputParser.getInstance().parseCompleteInput(userInput);
        query.userInput = userInput;
        
        switch (query.getQueryType()) {
            case DATETEST:
                DateRange[] dateRanges = DateTimeParser.parseDateTime(userInput);
                displayMessage( "User input: [" + userInput + "]" );
                displayMessage("Matched " + dateRanges.length + " dates");

                for(DateRange range:dateRanges) {
                    displayMessage("   " + range.toString());
                }
                break;
            case LIST:
                currentListQuery = (QueryList)query;
                break;
            case EXIT:
                Controller.stopTimer();
                System.exit(0);
                break;
            default:
                query.controllerExecute();
                break;
        }
        refreshDisplay();
    }


```
###### carelender\controller\states\AppState.java
``` java
package carelender.controller.states;

/**
 * Enum for the application states
 */
public enum AppState {
    FIRSTSTART,     //Shown to the user when the application first starts
    DEFAULT        //Normal screen the user sees
}
```
###### carelender\controller\states\BlockingState.java
``` java
package carelender.controller.states;

/**
 * Used when the program requires the user to input some data
 */
public enum BlockingState {
    NONE,
    EVENTSELECTION,       //Used for selecting multiple events.
    SELECTION,      //Used for selecting options
    CONFIRMING,     //A confirmation screen for deleting or editing items
    REMINDER,
    POPUP
}
```
###### carelender\controller\states\BlockingStateController.java
``` java
package carelender.controller.states;

import carelender.controller.Controller;
import carelender.controller.callbacks.OnConfirmedCallback;
import carelender.controller.callbacks.OnEventSelectedCallback;
import carelender.controller.callbacks.OnSelectedCallback;
import carelender.model.data.EventList;
import carelender.model.data.Event;
import carelender.model.strings.ErrorMessages;

/**
 * Manages the logic for the states that require user input
 */
public class BlockingStateController {
    private BlockingState blockingState;
    private OnEventSelectedCallback onEventSelectedCallback;
    private OnSelectedCallback onSelectedCallback;
    private OnConfirmedCallback onConfirmedCallback;

    //Temp variables
    private EventList selectionList; //Used for selecting multiple events
    private String [] stringSelectionList; //Used for selecting multiple choices


    public BlockingStateController() {
        blockingState = BlockingState.NONE;
        onEventSelectedCallback = null;
        onConfirmedCallback = null;
        onSelectedCallback = null;
    }

    /**
     * Called before the normal processing.
     * Blocks the rest of the program from running when user input is required.
     * @param userInput user's input
     * @return true if program is blocked
     */
    public boolean processBlockingState ( String userInput ) {
        switch (blockingState) {
            case EVENTSELECTION:
                stateEventSelection(userInput);
                break;
            case SELECTION:
                stateSelection(userInput);
                break;
            case CONFIRMING:
                stateConfirming(userInput);
                break;
            case REMINDER:
                stateReminder(userInput);
                break;
            case POPUP:
                statePopup(userInput);
                break;

            default:
                return false;
        }
        return true;
    }

    /**
     * Set the application into a choosing mode
     * @param message Message to show to user before displaying the choices
     * @param choices List of events to choose from
     * @param callback Code to be run after the choosing is complete
     */
    public void startSelection(String message, String [] choices, OnSelectedCallback callback) {
        blockingState = BlockingState.SELECTION;
        stringSelectionList = choices;
        onSelectedCallback = callback;

        Controller.clearMessages();
        Controller.displayMessage(message);
        StringBuilder stringBuilder = new StringBuilder();
        String breakline = "";
        int count = 0;
        for ( String choice : choices ) {
                count++;
                stringBuilder.append(breakline);
                breakline = System.lineSeparator();
                stringBuilder.append(count);
                stringBuilder.append(". ");
                stringBuilder.append(choice);
            }
        Controller.displayMessage(stringBuilder.toString());
    }

    /**
     * Set the application into a choosing mode
     * @param message Message to show to user before displaying the choices
     * @param choices List of events to choose from
     * @param callback Code to be run after the choosing is complete
     */
    public void startEventSelection(String message, EventList choices, OnEventSelectedCallback callback) {
        blockingState = BlockingState.EVENTSELECTION;
        selectionList = choices;
        onEventSelectedCallback = callback;
        Controller.clearMessages();
        Controller.displayMessage(selectionList.toString());
    }

    /**
     * Set the application into a confirmation mode
     * @param message Message to show user
     */
    public void startConfirmation ( String message, OnConfirmedCallback callback ) {
        Controller.getUI().displayPopup(message);
        blockingState = BlockingState.CONFIRMING;
        onConfirmedCallback = callback;
        /*Controller.clearMessages();
        Controller.displayMessage(message);*/
    }

    public void startPopup ( String message ) {
        Controller.getUI().displayPopup(message);
        blockingState = BlockingState.POPUP;
    }
    public void startEventPopup ( Event event ) {
        Controller.getUI().displayEventPopup(event);
        blockingState = BlockingState.POPUP;
    }



    /**
     * This state is used when the user is required to choose from a list of choices
     * @param userInput User's input
     */
    private void stateSelection(String userInput) {
        try {
            int chosen = Integer.parseInt( userInput );
            if ( chosen < 1 || chosen > stringSelectionList.length ) {
                Controller.displayMessage(ErrorMessages.invalidNumberRange(1, stringSelectionList.length));
            } else {
                blockingState = BlockingState.NONE;
                if ( onSelectedCallback != null ) {
                    onSelectedCallback.onChosen(chosen-1);
                }
            }
        } catch ( NumberFormatException e ) {
            Controller.displayMessage(ErrorMessages.invalidNumber());
        }
    }

    /**
     * This state is used when the user is required to choose from a list of events
     * @param userInput User's input
     */
    private void stateEventSelection(String userInput) {
        try {
            int chosen = Integer.parseInt( userInput );
            if ( chosen < 1 || chosen > selectionList.size() ) {
                Controller.displayMessage(ErrorMessages.invalidNumberRange(1, selectionList.size()));
            } else {
                Event selectedObject = selectionList.get(chosen-1);
                blockingState = BlockingState.NONE;
                if ( onEventSelectedCallback != null ) {
                    onEventSelectedCallback.onChosen(selectedObject);
                }
            }
        } catch ( NumberFormatException e ) {
            Controller.displayMessage(ErrorMessages.invalidNumber());
        }
    }

    private void stateConfirming(String userInput) {
        userInput = userInput.trim().toLowerCase();
        if ( userInput.startsWith("y") ) {
            blockingState = BlockingState.NONE;
            if ( onConfirmedCallback != null ) {
                onConfirmedCallback.onConfirmed(true);
            }
            Controller.getUI().clearPopup();
        } else if ( userInput.startsWith("n") ) {
            blockingState = BlockingState.NONE;
            if ( onConfirmedCallback != null ) {
                onConfirmedCallback.onConfirmed(false);
            }
            Controller.getUI().clearPopup();
        } else {
            Controller.getUI().displayPopup(ErrorMessages.invalidConfirmation());
        }
    }

    private void statePopup(String userInput) {
        blockingState = BlockingState.NONE;
        Controller.getUI().clearPopup();
    }

    private void stateReminder(String userInput) {
        blockingState = BlockingState.NONE;
    }


    public BlockingState getBlockingState() {
        return blockingState;
    }

    public boolean isBlocked () {
        return blockingState != BlockingState.NONE;
    }
}
```
###### carelender\controller\states\StateManager.java
``` java
package carelender.controller.states;


/**
 * Manages the states of the application
 */
public class StateManager {
    private AppState appState;
    private AppState prevState;

    public StateManager() {
        appState = AppState.FIRSTSTART;
        prevState = null;
    }

    /**
     * Changes the application state
     * @param newState State to change to
     */
    public void changeState ( AppState newState ) {
        if ( appState == newState ) return;
        prevState = appState;
        appState = newState;
        System.out.println("State changed: " + newState.toString());
    }

    public AppState getPrevState() {
        return prevState;
    }

    public AppState getAppState() {
        return appState;
    }

    public boolean isState ( AppState state ) {
        return state == appState;
    }


}
```
###### carelender\model\CommandAutomation.java
``` java
package carelender.model;

/**
 * Class to automate commands for testing or the presentation
 */
public class CommandAutomation {
    private static CommandAutomation singleton = null;
    public static CommandAutomation getInstance() {
        if ( singleton == null ) {
            singleton = new CommandAutomation();
        }
        return singleton;
    }

    int i = 0;
    String [] commands;
    private CommandAutomation() {
        commands = Model.getInstance().loadStringArray("automation.dat");
    }

    public String getNext() {
        if ( i >= commands.length ) {
            return null;
        }
        return commands[i++];
    }
    public String getPrev() {
        if ( i <= 0 ) {
            return null;
        }
        return commands[i--];
    }
}
```
###### carelender\model\data\Event.java
``` java
    public String getDetailedInfo() {
        String dateConcat = " ";
        StringBuilder sb = new StringBuilder();
        sb.append(name);
        sb.append(" | ");

        for ( DateRange dateRange : this.dateRange ) {
            sb.append(dateConcat);
            dateConcat = ", ";

            String startString = DateFormats.DEBUG_FORMAT.format(dateRange.getStart());
            sb.append(startString);
            if ( dateRange.isRange() ) {
                String endString = DateFormats.DEBUG_FORMAT.format(dateRange.getEnd());
                sb.append(" - ");
                sb.append(endString);
            }
        }

        if ( category != null ) {
            sb.append( "| cat: ");
            sb.append(category);
            sb.append(" ");
        }

        if ( completed ) {
            sb.append("| complete");
        } else {
            sb.append("| incomplete");
        }
        return sb.toString();
    }

    public Event copy () {
        return new Event(this);
    }
```
###### carelender\model\data\QueryAdd.java
``` java
package carelender.model.data;

import carelender.controller.Controller;
import carelender.model.Model;
import carelender.model.strings.QueryFeedback;

/**
 * Used for add queries
 */
public class QueryAdd extends QueryBase {
    String name;
    String category;
    DateRange [] dateRanges;

    public QueryAdd() {
        super(QueryType.ADD);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCategory() {
        return category;
    }

    public void setCategory(String category) {
        this.category = category;
    }

    public DateRange[] getDateRange() {
        return dateRanges;
    }

    public void setDateRange(DateRange [] dateRange) {
        this.dateRanges = dateRange;
    }
    public void setDateRange(DateRange dateRange) {
        this.dateRanges = new DateRange[1];
        this.dateRanges[0] = dateRange;
    }

    @Override
    public void controllerExecute() {
        Controller.displayMessage(QueryFeedback.addTask(name));
        Model.getInstance().addEvent(convertToEventObject());
    }

    @Override
    public EventList searchExecute() {
        return null;
    }

    /**
     * Converts this query object into an event object
     * @return Event object
     */
    public Event convertToEventObject() {
        return new Event(0, getName(), getDateRange(), getCategory());
    }
    
    
}
```
###### carelender\model\data\QueryBase.java
``` java
package carelender.model.data;

/**
 * Base class for all query objects
 */
public abstract class QueryBase {
    public String userInput;
    private QueryType queryType;

    //Do not allow anyone to create a QueryBase
    protected QueryBase(QueryType queryType) {
        this.queryType = queryType;
    }
    
    public QueryType getQueryType() {
        return queryType;
    }
    
    public abstract void controllerExecute();
    public abstract EventList searchExecute();
}
```
###### carelender\model\data\QueryDelete.java
``` java
package carelender.model.data;

import carelender.controller.Controller;
import carelender.controller.callbacks.OnConfirmedCallback;
import carelender.model.Model;
import carelender.model.strings.QueryFeedback;

/**
 * Used for delete queries
 */
public class QueryDelete extends QueryBase {
    private EventList events;
    public QueryDelete() {
        super(QueryType.DELETE);
        events = new EventList();
    }

    //private Event selectedObject; // Used for confirmation

    public void addEvent ( Event e ) {
        events.add(e.copy());
    }

    public void setEventList ( EventList e ) {
        events = e;
    }
    
    @Override
    public void controllerExecute() {
        final OnConfirmedCallback deleteConfirmedCallback = new OnConfirmedCallback() {
            @Override
            public void onConfirmed(boolean confirmed) {
                if ( confirmed ) {
                    Model.getInstance().deleteEvent(events);
                    Controller.displayMessage(QueryFeedback.deleteTask(events.size()));
                } else {
                    Controller.displayMessage(QueryFeedback.deleteCancelled());
                }
                Controller.refreshDisplay();
            }
        };

        if ( events != null && events.size() > 0 ) {
            if ( events.size() == 1 ) {
                deleteConfirmedCallback.onConfirmed(true);
            } else {
                Controller.getBlockingStateController()
                        .startConfirmation(QueryFeedback.deleteConfirmation(events.size()), deleteConfirmedCallback);
            }
        }


        /*final OnEventSelectedCallback deleteCallback = new OnEventSelectedCallback() {
            @Override
            public void onChosen(Event selected) {
                selectedObject = selected;
                Controller.getBlockingStateController()
                        .startConfirmation("Are you sure you want to delete \"" + selected.getName() + "\"? [Y/N]", deleteConfirmedCallback);
            }
        };*/

        /*if ( searchResults.size() == 0 ) {
            Controller.displayMessage("There is no task called " + getName());
        } else if ( searchResults.size() > 1 ) {
            String message = "There are multiple \""+ getName()+"\" tasks, please choose the one to delete.";
            Controller.getBlockingStateController().startEventSelection(message, searchResults, deleteCallback);
        } else {
            deleteCallback.onChosen(searchResults.get(0));
        }*/


    }

    @Override
    public EventList searchExecute() {
        EventList returnList = new EventList();

        /*if (Model.getInstance().retrieveEvent() != null) {
            for (Event event : Model.getInstance().retrieveEvent()) {
                if (Search.isEventNameExact(event, getName())) {
                    returnList.add(event.copy());
                }
            }
        }*/
        return returnList;
    }
}
```
###### carelender\model\data\QueryError.java
``` java
package carelender.model.data;

import carelender.controller.Controller;

/**
 * Used for queries that cannot be parsed.
 * Simply prints the error to screen
 */
public class QueryError extends QueryBase {
    private String message;
    private boolean isHelpDisplayed;

    public QueryError(String message) {
        super(QueryType.ERROR);
        this.message = message;
    }
    public QueryError(String message, boolean isHelpDisplayed) {
        super(QueryType.ERROR);
        this.message = message;
        this.isHelpDisplayed = isHelpDisplayed;
    }

    public String getMessage() {
        return message;
    }

    public boolean isHelpDisplayed() {
        return isHelpDisplayed;
    }
    
    @Override
    public void controllerExecute() {
        Controller.displayMessage(getMessage());
        if ( isHelpDisplayed() ) {
            Controller.showHelp();
        }
    }

    @Override
    public EventList searchExecute() {
        return null;
    }
}
```
###### carelender\model\data\QueryGeneric.java
``` java
package carelender.model.data;

/**
 * Used for queries that do not require any additional data
 */
public class QueryGeneric extends QueryBase {
    public QueryGeneric(QueryType queryType) {
        super(queryType);
    }
    
    @Override
    public void controllerExecute() {
    }

    @Override
    public EventList searchExecute() {
        return null;
    }
}
```
###### carelender\model\data\QueryHelp.java
``` java
package carelender.model.data;

import carelender.controller.Controller;

/**
 * Used for help queries
 */
public class QueryHelp extends QueryBase {
    public QueryHelp() {
        super(QueryType.HELP);
    }
    
    @Override
    public void controllerExecute() {
        Controller.clearMessages();
        Controller.showHelp();
    }

    @Override
    public EventList searchExecute() {
        return null;
    }
}
```
###### carelender\model\strings\AppColours.java
``` java
package carelender.model.strings;

import javafx.scene.paint.Color;

/**
 * Colours of the program
 */
public class AppColours {
    public final static Color panelBackground = Color.web("fafafa");
    public final static Color panelText = Color.web("000");
    public final static Color calendarCell = Color.web("556370");
    public final static Color calendarTodayCell = Color.web("366F70");
    public final static Color tasklistRowBackground = Color.web("757575");
    public final static Color tasklistText = Color.web("eeeff0");
    public final static Color primaryColour = Color.web("4ecdc4");
    public final static Color autocompleteBackground = Color.web("e8e8e8");
    public final static Color autocompleteText = Color.web("000");
    public final static Color tabBackground = Color.web("999");
    public final static Color tabText = Color.web("555");
    public final static Color popupBackground = Color.web("e8e8e8");
    public final static Color popupHeaderBackground = Color.web("757575");
    public final static Color popupText = Color.web("000");
    public final static Color tabHighlight = Color.web("FF0");
    public final static Color black = Color.web("000");
    public final static Color white = Color.web("FFF");
    public final static Color grey = Color.web("555");
    public final static Color important = Color.web("bd4d59");
    public final static Color information = Color.web("c7f464");
    
    public final static int NUM_CATEGORIES = 5;
    public final static Color [] category = {Color.web("d1686e"),
                                            Color.web("d4986a"),
                                            Color.web("5fae57"),
                                            Color.web("41837e"),
                                            Color.web("a45287")};
}
```
###### carelender\model\strings\DateFormats.java
``` java
package carelender.model.strings;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

/**
 * Contains all the date formats
 */
public class DateFormats {
    public static final SimpleDateFormat TIME_FORMAT = new SimpleDateFormat("HH:mm");
    public static final SimpleDateFormat DAY_IN_YEAR = new SimpleDateFormat("D");
    public static final SimpleDateFormat YEAR = new SimpleDateFormat("y");
    public static final SimpleDateFormat DATE_FORMAT_DAY = new SimpleDateFormat("d EEE");
    public static final SimpleDateFormat DATE_FORMAT_MONTH = new SimpleDateFormat("dd MMM");
    public static final SimpleDateFormat DATE_FORMAT_YEAR = new SimpleDateFormat("MMM YYYY");
    public static final SimpleDateFormat DEBUG_FORMAT = new SimpleDateFormat("E dd MMM h:mma");
    
```
###### carelender\model\strings\ErrorMessages.java
``` java
package carelender.model.strings;

/**
 * Messages for different errors
 */
public class ErrorMessages {
    public static String invalidCommand( String command ) {
        return "[" + command + "] is not a valid command. Type ? for help.";
    }

    public static String tooManyDateRange() {
       return "Please input at most one date range";
    }
    public static String emptySearch() {
        return "Please input something to search";
    }

    public static String addNoParameters() {
        return "What would you like to add?";
    }
    public static String deleteNoParameters() {
        return "What would you like to delete?";
    }

    public static String completeNoParameters() {
        return "What would you like to complete?";
    }

    public static String setNoParameters() {
        return "What would you like to set?";
    }
    public static String updateNoParameters() {
        return "What would you like to update?";
    }

    public static String remindNoParameters() {
        return "What do you want a reminder for?";
    }
    public static String nothingListed() {
        return "There is nothing displayed, please use the list or search commands";
    }

    public static String invalidIndices() {
        return "Error parsing indices";
    }
    public static String singleIndexOnly() {
        return "Please input only one index";
    }

    public static String invalidUpdate() {
        return "Update command invalid";
    }


    public static String invalidConfirmation() {
        return "Sorry, we didn't understand you. Please say [Yes] or [No]";
    }
    public static String invalidNumberRange(int start, int end) {
        return "You've chosen an invalid option, please enter a number between " + start + " and " + end;
    }
    public static String invalidNumber() {
        return "Please input a number";
    }
    public static String invalidNumber(String s) {
        return s + " is not a number. Please input a number";
    }

}
```
###### carelender\model\strings\FirstStartMessages.java
``` java
package carelender.model.strings;

/**
 * All the messages that will be shown to the user when we first start.
 */
public class FirstStartMessages {
    public static String confirmation(String username) {
        return "Okay, we'll call you " + username + " from now on. [Yes/No]";
    }
    public static String confirmed(String username) {
        return "Alright, " + username + " let's start";
    }
    public static String askForName() {
        return "Hi there, before we start, what should we call you?";
    }
    public static String askForNameAgain() {
        return "Please tell us what to call you.";
    }
    public static String firstStart() {
        return "Welcome to CARELender(TM). ";
    }
    public static String welcomeBack( String username ) {
        return "Welcome back, " + username;
    }


}
```
###### carelender\model\strings\FontLoader.java
``` java
package carelender.model.strings;

import javafx.scene.text.Font;

/**
 * Used to create the fonts throughout the application
 */
public class FontLoader {
    public static Font load(double size) {
        return Font.loadFont("file:res/monaco.ttf", size);
    }
    public static double FONT_WIDTH_RATIO = 0.6; //Ratio of the font width to height
    public static double DEFAULT_LINE_HEIGHT_RATIO = 0.05; //Ratio of the font width to height
}
```
###### carelender\model\strings\QueryFeedback.java
``` java
package carelender.model.strings;

/**
 * Class to get feedback strings for all queries
 */
public class QueryFeedback {
    public static String addTask(String name) {
        return "Added [" + name + "]";
    }
    public static String deleteTask (String name ) {
        return "Deleted ["+name+"]";
    }
    public static String deleteTask (int count ) {
        return "Deleted "+count+" tasks";
    }
    public static String completeTask (String name ) {
        return "Completed ["+name+"]";
    } 
    public static String completeTask (int count ) {
    	return "Completed "+count+" tasks";
    } 
    public static String uncompleteTask (int count ) {
    	return "Uncompleted "+count+" tasks";
    } 
    public static String deleteConfirmation (int count) {
        return "Are you sure you want to delete " + count + " events? [Y/N]";
    }
    public static String deleteCancelled () {
        return "Cancelled, nothing deleted :)";
    }
    public static String updateCancelled () {
        return "Cancelled, nothing updated :)";
    }

    public static String reminderAdded(int size) {
        return size + " reminders added";
    }

    public static String reminderAdded() {
        return "Reminder added!";
    }
}
```
###### carelender\test\ParserTest.java
``` java
package carelender.test;

import java.util.Calendar;
import java.util.Date;

import org.junit.Test;

import carelender.model.data.DateRange;
import carelender.model.data.Event;
import carelender.model.data.EventList;
import carelender.model.data.QueryAdd;
import carelender.model.data.QueryBase;
import carelender.model.data.QueryGeneric;
import carelender.model.data.QueryType;
import carelender.view.parser.InputParser;
import static org.junit.Assert.*;

public class ParserTest extends InputParser {

    /**
     * Tests the index parsing used for the functions used to detect ranges.
     */
    @Test
    public void testIndexParsing() {
        //This part is required for the indices to work
        EventList events = new EventList();
        for ( int i = 0 ; i < 15; i++ ) {
            Event e = new Event(i, null, null, null);
            events.add(e);
        }
        setDisplayedList(events);

        //Simple case
        String case1 = "1,2,3";
        Integer[] indices = extractIndices(case1);
        Integer[] expected1 = {0,1,2};
        assertArrayEquals(expected1, indices);

        //Case with range
        String case2 = "1,2,3-10";
        indices = extractIndices(case2);
        Integer[] expected2 = {0,1,2,3,4,5,6,7,8,9};
        assertArrayEquals(expected2, indices);

        //Unsorted and with spaces
        String case3 = "1, 13, 5-8";
        indices = extractIndices(case3);
        Integer[] expected3 = {0,4,5,6,7,12};
        assertArrayEquals(expected3, indices);

        //Wrong order and boundary case
        String case4 = "1-3, 15-13";
        indices = extractIndices(case4);
        Integer[] expected4 = {0,1,2,12,13,14};
        assertArrayEquals(expected4, indices);

        //Out of bounds case
        String case5 = "1,13,5-8,20";
        indices = extractIndices(case5);
        assertArrayEquals(null, indices);

    }

    @Test
    public void testHelperFunctions() {

        String [] originalEmptyEntry = { "Hello", "", "I'm not", "empty" };
        String [] resultEmptyEntry = removeEmptyEntries(originalEmptyEntry);
        String [] expectedEmptyEntry = { "Hello", "I'm not", "empty" };

        assertArrayEquals(expectedEmptyEntry, resultEmptyEntry);

        String userInput = "This is string   \"Literals and such\" \"andr andomSpa ces ";
        String [] resultSplit = splitQuery(userInput);
        String [] expectedSplit = { "This", "is", "string", "Literals and such", "andr andomSpa ces" };

        assertArrayEquals(expectedSplit, resultSplit);

        String resultString =  removeQuotes(userInput);
        String expectedString = "This is string   \"=================\" \"==================";

        assertEquals(expectedString, resultString);
    }


    @Test
    public void testCommands() {
        String userInput = "exit";
        QueryBase result = parseCompleteInput(userInput);
        QueryBase expected = new QueryGeneric(QueryType.EXIT);

        assertEquals(result.getQueryType(), expected.getQueryType());

        userInput = "switch";
        result = parseCompleteInput(userInput);
        expected = new QueryGeneric(QueryType.SWITCHUI);

        assertEquals(result.getQueryType(), expected.getQueryType());
    }

    @Test
    public void testAddParsing() {
        //User input
        String userInput = "add \"Morning event\" tomorrow 4pm - 5pm cat hehe";
        QueryBase result = parseCompleteInput(userInput);
        if ( !(result instanceof QueryAdd) ) {
            assertTrue("Not a QueryAdd instance", false);
        }
        //Formatting the user input into a string
        QueryAdd resultAdd = (QueryAdd)result;
        Event event = resultAdd.convertToEventObject();
        String eventString = event.getDetailedInfo();

        //Creating the expected result
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DATE,		  1);
        cal.set(Calendar.MILLISECOND, 0);
        cal.set(Calendar.SECOND,	  0);
        cal.set(Calendar.MINUTE,	  0);
        cal.set(Calendar.HOUR_OF_DAY, 16);
        Date startDate = cal.getTime();
        cal.set(Calendar.HOUR_OF_DAY, 17);
        Date endDate = cal.getTime();
        DateRange [] dateRange = new DateRange[1];
        dateRange[0] = new DateRange(startDate, endDate, true);
        Event expectedEvent = new Event(0, "Morning event", dateRange, "hehe");
        String expected = expectedEvent.getDetailedInfo();
        assertEquals(expected, eventString);

        //User input
        userInput = "add \"TGI Friday's and dinner\" 10 days from now 6.30pm - 8pm , 12 days from now 6pm - 7.30pm cat dinner";
        result = parseCompleteInput(userInput);
        if ( !(result instanceof QueryAdd) ) {
            assertTrue("Not a QueryAdd instance", false);
        }
        //Formatting the user input into a string
        resultAdd = (QueryAdd)result;
        event = resultAdd.convertToEventObject();
        eventString = event.getDetailedInfo();

        //Creating the expected result
        dateRange = new DateRange[2];

        cal = Calendar.getInstance();
        cal.add(Calendar.DATE,		  10);
        cal.set(Calendar.MILLISECOND, 0);
        cal.set(Calendar.SECOND,	  0);
        cal.set(Calendar.HOUR_OF_DAY, 18);
        cal.set(Calendar.MINUTE,	  30);
        startDate = cal.getTime();
        cal.set(Calendar.HOUR_OF_DAY, 20);
        cal.set(Calendar.MINUTE,	  0);
        endDate = cal.getTime();

        dateRange[0] = new DateRange(startDate, endDate, true);

        cal.add(Calendar.DATE,		  2);
        cal.set(Calendar.HOUR_OF_DAY, 18);
        cal.set(Calendar.MINUTE,	  0);
        startDate = cal.getTime();
        cal.set(Calendar.HOUR_OF_DAY, 19);
        cal.set(Calendar.MINUTE,	  30);
        endDate = cal.getTime();

        dateRange[1] = new DateRange(startDate, endDate, true);

        expectedEvent = new Event(0, "TGI Friday's and dinner", dateRange, "dinner");
        expected = expectedEvent.getDetailedInfo();
        assertEquals(expected, eventString);
        System.out.println(expected);
        System.out.println(eventString);

    }

}
```
###### carelender\view\gui\CanvasRenderer.java
``` java
package carelender.view.gui;

import javafx.scene.canvas.GraphicsContext;

/**
 * This is the renderer class that the canvas class will use to draw.
 * It has to be extended and the child class should override draw to do the drawing
 */
public abstract class CanvasRenderer {
    protected GraphicsContext gc = null;
    protected double x = 0;
    protected double y = 0;
    protected double width = 0;
    protected double height = 0;

    public CanvasRenderer() {}

    public void draw ( GraphicsContext gc, double x, double y, double width, double height ) {
        this.gc = gc;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        gc.clearRect(x, y, width, height);
    }
    public void redraw() {
        if ( gc == null ) {
            return;
        }
        draw(gc, x, y, width,height);
    }
}
```
###### carelender\view\gui\components\AutocompleteRenderer.java
``` java
package carelender.view.gui.components;

import carelender.model.strings.AppColours;
import carelender.model.strings.FontLoader;
import carelender.view.gui.CanvasRenderer;
import javafx.geometry.VPos;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;

/**
 * Renders the autocomplete box and automatically resizes the height according to the number of lines.
 */
public class AutocompleteRenderer extends CanvasRenderer {
    public static final double FONT_RATIO = 1/80.0;
    public static final double HINT_FONT_RATIO = 1/90.0;
    public static final double INNER_PADDING = 5;

    public static final String TAB_TO_AUTOCOMPLETE = "TAB to autocomplete";
    String [] autocompleteOptions = null;
    TextRenderer autoComplete = new TextRenderer();
    boolean renderFirstLineBold;

    @Override
    public void draw(GraphicsContext gc, double x, double y, double width, double height) {
        super.draw(gc, x, y, width,height);

        if ( autocompleteOptions != null ) {
            double fontSize = width * FONT_RATIO;


            double fieldHeight = autocompleteOptions.length * ( 1 + FontLoader.DEFAULT_LINE_HEIGHT_RATIO) * fontSize + INNER_PADDING * 2;

            if ( renderFirstLineBold ) {
                gc.setFont(FontLoader.load(width * HINT_FONT_RATIO));
                gc.setTextBaseline(VPos.BOTTOM);
                gc.setFill(AppColours.grey);
                gc.setStroke(AppColours.grey);
                gc.setTextAlign(TextAlignment.LEFT);
                gc.fillText(TAB_TO_AUTOCOMPLETE, x + INNER_PADDING * 2, y - fieldHeight - INNER_PADDING);
                gc.strokeText(TAB_TO_AUTOCOMPLETE, x + INNER_PADDING * 2, y - fieldHeight - INNER_PADDING);
            }

            Font font = FontLoader.load( fontSize );
            autoComplete.setParams(gc, x, y - fieldHeight, width, fieldHeight,
                    INNER_PADDING, INNER_PADDING, font, FontLoader.DEFAULT_LINE_HEIGHT_RATIO);

            for ( String autocompleteOption : autocompleteOptions ) {
                autoComplete.addTextEllipsis(autocompleteOption);
            }

            autoComplete.drawText(AppColours.autocompleteBackground, AppColours.autocompleteText, renderFirstLineBold?1:0);
        }
    }

    /**
     * Sets the lines of text for the autocomplete options
     * @param autocompleteOptions String array for all the options to show
     * @param renderFirstLineBold Flag to bold the first line
     */
    public void setAutocompleteOptions(String[] autocompleteOptions, boolean renderFirstLineBold) {
        this.renderFirstLineBold = renderFirstLineBold;
        this.autocompleteOptions = autocompleteOptions;
        redraw();
    }
}
```
###### carelender\view\gui\components\CalenderRenderer.java
``` java
    public CalenderRenderer() {        
        monthEventNumbers = new int[NUMBER_OF_SQUARES][NUMBER_OF_RANGES_PER_DAY];
        resetEventNumbers();
        
        monthListQuery = new QueryList();
        
        Calendar cal = Calendar.getInstance();
        cal.setFirstDayOfWeek(Calendar.MONDAY);
        cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
        cal.set(Calendar.MILLISECOND, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.HOUR_OF_DAY, 0);
        monthStartTime = cal.getTime();
        cal.add(Calendar.DAY_OF_MONTH, NUMBER_OF_SQUARES);
        monthEndTime = cal.getTime();

        monthListQuery.addSearchParam(QueryList.SearchParam.DATE_START, monthStartTime);
        monthListQuery.addSearchParam(QueryList.SearchParam.DATE_END, monthEndTime);
        refreshEventList();
    }

    public void refreshEventList() {
        monthEvents = monthListQuery.searchExecute();
        updateEventNumbers();
        HintGenerator.getInstance().setEventNumbers(monthEventNumbers);
        System.out.println("CalendarRenderer refreshed: " + monthEvents.size() + " items in the month");
    }

    double sidePadding;
    double usableWidth;
    double calCellWidth;
    double calCellHeight;
    double calCellSpacing;
    double calCellShadowOffset;

    double scaledWidth, scaledHeight;
    double offsetX, offsetY;

    @Override
    public void draw(GraphicsContext gc, double x, double y, double width, double height) {
        super.draw(gc, x, y, width, height);
        calculateScaledDimensions(width, height);
        calulateCellProperties();
        
        Calendar c = Calendar.getInstance();
        int todayDate = c.get(Calendar.DATE);
        int thisMonth = c.get(Calendar.MONTH);
        c.setFirstDayOfWeek(Calendar.MONDAY);
        c.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);

        gc.setFill(AppColours.panelBackground);
        gc.fillRect(x, y, width, height);

        Font font = FontLoader.load( calCellHeight * FIRST_FONTSIZE_RATIO);

        gc.setFill(AppColours.calendarCell);
        gc.setTextAlign(TextAlignment.CENTER);
        gc.setFont(font);
        gc.setTextBaseline(VPos.TOP);
        for (int i = 0 ; i < NUMBER_OF_DAYS_PER_WEEK; i++ ) {
            double actualX = x + i * ( calCellWidth + calCellSpacing ) + sidePadding + offsetX + calCellWidth * 0.5;
            double actualY = y + offsetY + sidePadding;
            gc.fillText(DAYS[i], actualX, actualY);
        }

        font = FontLoader.load( calCellHeight * SECOND_FONTSIZE_RATIO);
        double monthSpacer = 0;
        for (int i = 0; i < NUMBER_OF_SQUARES; i++ ) {
            double actualX = x + i%NUMBER_OF_DAYS_PER_WEEK * ( calCellWidth + calCellSpacing ) + sidePadding;
            double actualY = y + (i/NUMBER_OF_DAYS_PER_WEEK) * ( calCellHeight + calCellSpacing ) + sidePadding;

            int date = c.get(Calendar.DATE);
            if ( i == 0 ) {
                monthSpacer += (calCellSpacing * 4) + sidePadding;
            } else if ( date == 1 ) {
                monthSpacer += (calCellHeight + calCellSpacing * 4) + sidePadding;
            }

            actualX += offsetX;
            actualY += offsetY + calCellHeight * 0.5 + monthSpacer;

            if ( date == 1 || i == 0 ) {
                gc.setFont(font);
                gc.setFill(Color.web("#BBB"));
                gc.fillRect(sidePadding + x + offsetX, actualY - calCellHeight * 0.6, scaledWidth - sidePadding * 2 - calCellShadowOffset, calCellHeight * 0.5);
                gc.setFill(Color.web("#000"));
                gc.setTextBaseline(VPos.TOP);
                gc.setTextAlign(TextAlignment.LEFT);

                gc.fillText(getMonth(c.get(Calendar.MONTH) ), sidePadding + x + offsetX + sidePadding, actualY - calCellHeight * 0.5);
            }

            int[] dailyEventNumbers = monthEventNumbers[i];

            Color calendarCell = AppColours.calendarCell;
            if ( c.get(Calendar.DATE) == todayDate && c.get(Calendar.MONTH) == thisMonth ) {
                calendarCell = AppColours.calendarTodayCell;
            }
            calendarSquare(actualX, actualY,
                    calCellWidth, calCellHeight,
                    calCellShadowOffset,
                    calendarCell, AppColours.primaryColour,
                    date + "", font, dailyEventNumbers);
            c.add(Calendar.DATE, 1);
            
        }
    }

```
###### carelender\view\gui\components\CalenderRenderer.java
``` java
    private String getMonth(int month) {
        return new DateFormatSymbols().getMonths()[month];
    }

    private void calculateScaledDimensions(double width, double height) {
       
        double squareHeight = height * ASPECT;

        if ( width > squareHeight ) { //Height is the constraint
            scaledWidth = height * ASPECT;
            scaledHeight = height;
        } else { //Width is the constraint
            scaledWidth = width;
            scaledHeight = width / ASPECT;
        }

        offsetX = (width - scaledWidth) * SCALED_OFFSETX_RATIO;
        offsetY = 0;//(height - scaledHeight) * 0.5;
    }

    private void calulateCellProperties() {
        sidePadding = scaledWidth * CAL_CELL_SIDE_PADDING_RATIO;
        usableWidth = scaledWidth - sidePadding * CAL_CELL_USABLE_WIDTH_RATIO; // Give 2.5% padding on each size
        calCellWidth = usableWidth * CAL_CELL_WIDTH_RATIO;
        calCellSpacing = calCellWidth * CAL_CELL_SPACING_RATIO; //Make spacing 10% of each cell size
        calCellWidth -= calCellSpacing;
        calCellHeight = calCellWidth * CAL_CELL_HEIGHT_WIDTH_RATIO;
        calCellShadowOffset = calCellSpacing * CAL_CELL_SHADOW_OFFSET_RATIO;
    }

    /**
     * Draws a calendar square with a drop shadow
     * @param x X position
     * @param y Y position
     * @param w Width
     * @param h Height
     * @param dropOffset Offset of drop shadow
     * @param background Colour of square
     * @param textColor Colour of text
     * @param text Text to show at bottom right
     * @param dailyEventNumbers Array of integers to show the dots
     */
    public void calendarSquare ( double x, double y, double w, double h, double dropOffset, Color background, Color textColor, String text, Font font, int[] dailyEventNumbers ) {
        gc.setFill(Color.web("#999"));
        gc.fillRect(x + dropOffset, y + dropOffset, w, h);

        gc.setFill(background);
        gc.fillRect(x, y, w, h);

        gc.setFill(textColor);
        gc.setTextAlign(TextAlignment.RIGHT);
        gc.setTextBaseline(VPos.BOTTOM);
        gc.setFont(font);
        gc.fillText(text, x + w - dropOffset * 0.5 , y + h - dropOffset * 0.5 );

        double x_offset;
        double y_offset;

        for (int i = 0; i < dailyEventNumbers.length; i++) {
            int numArc = dailyEventNumbers[i];

            if (numArc > ARC_THRESHOLD) {
                numArc = ARC_THRESHOLD;
            }
            for (int j=0; j<numArc; j++) {
                gc.setFill(AppColours.primaryColour);
                x_offset = x + w*((double) j)/10.0 + w*((double) j + 1.0)/20.0;
                y_offset = y + h*((double) i)/10.0 + h*((double) i + 1.0)/20.0;
                gc.fillRect(x_offset, y_offset, w/10.0, h/10.0);
            }
        }
    }
}
```
###### carelender\view\gui\components\EventInfoRenderer.java
``` java
package carelender.view.gui.components;

import carelender.model.data.Event;
import carelender.model.strings.AppColours;
import carelender.model.strings.FontLoader;
import carelender.view.gui.CanvasRenderer;
import javafx.geometry.VPos;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;

/**
 * Renders the information of an event using the taskbar renderer class
 */
public class EventInfoRenderer extends CanvasRenderer {
    public final String title = "Event Details";
    Event event;
    TaskBarRenderer taskBarRenderer;
    public final float headerRatio = 0.06f;
    public EventInfoRenderer() {
        taskBarRenderer = new TaskBarRenderer();
        taskBarRenderer.setParams(10,10, 0.3);
    }

    public void setEvent(Event event) {
        this.event = event;
        taskBarRenderer.setContent(event);
    }
    @Override
    public void draw( GraphicsContext gc, double x, double y, double width, double height) {
        gc.setFill(AppColours.tasklistRowBackground);
        gc.fillRect(x, y, width, height);



        gc.setFill(AppColours.primaryColour);
        gc.fillRect(x, y, width, height * headerRatio);

        gc.setFill(AppColours.black);
        Font font = FontLoader.load( height * headerRatio * .8);
        gc.setFont(font);
        gc.setTextBaseline(VPos.TOP);
        gc.setTextAlign(TextAlignment.LEFT);
        gc.fillText(title, x, y);

        taskBarRenderer.draw(gc, x, y + height * headerRatio, width, width / 10, AppColours.tasklistRowBackground, AppColours.primaryColour, false);
    }
}
```
###### carelender\view\gui\components\TextRenderer.java
``` java
    /**
     * Add text to the message box in a single line with ellipsis
     * @param textLine Line of text to add. Breaklines will be removed
     */
    public void addTextEllipsis ( String textLine ) {
        if ( textLine == null ) {
            return;
        }
        if (this.gc == null) {
            System.out.println("Error");
        } else {
            textLine = textLine.replace("\n", " ");
            double freeCharsOnLine = this.charsPerLine - 4 ;// Size of "... "
            String [] wordsToAdd = textLine.split(" ");
            StringBuilder stringBuilder = new StringBuilder();
            boolean outOfSpace = false;
            for ( String wordToAdd : wordsToAdd ) {
                freeCharsOnLine -= wordToAdd.length() + 1; //+1 is for space character
                if ( freeCharsOnLine >= 0 ) {
                    stringBuilder.append(wordToAdd);
                    stringBuilder.append(" ");
                } else {
                    outOfSpace = true;
                    break;
                }
            }
            if ( outOfSpace) {
                stringBuilder.append("...");
            }
            this.textLines.add(stringBuilder.toString());
        }
    }

```
###### carelender\view\gui\ResizableCanvas.java
``` java
package carelender.view.gui;

import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;

/**
 * Canvas to extend the resizable component of
 */
public class ResizableCanvas extends Canvas {
    CanvasRenderer renderer;
    public ResizableCanvas() {
        // Redraw canvas when size changes.
        widthProperty().addListener(evt -> draw());
        heightProperty().addListener(evt -> draw());
    }

    private void draw() {
        double width = getWidth();
        double height = getHeight();
        if ( width == 0 || height == 0 ) {
            return;
        }
        GraphicsContext gc = getGraphicsContext2D();
        if ( renderer == null ) {
            //Draw a red cross
            gc.setStroke(Color.RED);

            gc.clearRect(0, 0, width, height);
            gc.strokeLine(0, 0, width, height);
            gc.strokeLine(0, height, width, 0);
        } else {
            renderer.draw(gc, 0, 0, width, height);
        }

        //System.out.println(width + ", " + height);
    }

    public void setRenderer(CanvasRenderer renderer) {
        this.renderer = renderer;
        draw();
    }

    @Override
    public boolean isResizable() {
        return true;
    }

    @Override
    public double prefWidth(double height) {
        return height;
        //return getWidth();
    }

    @Override
    public double prefHeight(double width) {
        return width;
        //return getHeight();
    }
}
```
###### carelender\view\gui\UIController.java
``` java
package carelender.view.gui;

import carelender.controller.Controller;
import carelender.model.CommandAutomation;
import carelender.model.data.Event;
import carelender.model.data.EventList;
import carelender.model.data.QueryList;
import carelender.view.gui.components.EventInfoRenderer;
import carelender.view.gui.components.PopupRenderer;
import carelender.view.gui.views.FloatingViewRenderer;
import carelender.view.gui.views.MonthViewRenderer;
import carelender.view.gui.views.SettingViewRenderer;
import carelender.view.gui.views.TimelineViewRenderer;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.StackPane;

import java.net.URL;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.ResourceBundle;

public class UIController implements Initializable {
    @FXML
    private TextField inputText;

    @FXML
    private StackPane canvasPane;

    public ArrayList<String> messageList;
    ResizableCanvas canvas;

    private UIType uiType;


    private MonthViewRenderer monthViewRenderer;
    private TimelineViewRenderer timelineViewRenderer;
    private FloatingViewRenderer floatingViewRenderer;
    private SettingViewRenderer settingViewRenderer;


    private PopupRenderer popupRenderer;
    private EventInfoRenderer eventInfoRenderer;
    private UIRenderer UIRenderer;
    private String firstOption;

    private String pendingAnnouncementMessage = null; //Used for the automation part

    @Override // This method is called by the FXMLLoader when initialization is complete
    public void initialize(URL fxmlFileLocation, ResourceBundle resources) {
        assert inputText != null : "fx:id=\"inputText\" was not injected: check your FXML file 'userinterface.fxml'.";
        assert canvasPane != null : "fx:id=\"canvasPane\" was not injected: check your FXML file 'userinterface.fxml'.";
        // initialize your logic here: all @FXML variables will have been injected

        //Create canvases using code
        canvas = new ResizableCanvas();
        canvasPane.getChildren().add(canvas);

        popupRenderer = new PopupRenderer();
        messageList = new ArrayList<>();

        UIRenderer = new UIRenderer();
        canvas.setRenderer(UIRenderer);

        // Bind canvas size to stack pane size.
        canvas.widthProperty().bind(
                canvasPane.widthProperty());
        canvas.heightProperty().bind(
                canvasPane.heightProperty());

        Controller.initUserInterfaceController(this);

        monthViewRenderer = new MonthViewRenderer();
        timelineViewRenderer = new TimelineViewRenderer();
        settingViewRenderer = new SettingViewRenderer();
        floatingViewRenderer = new FloatingViewRenderer();

        eventInfoRenderer = new EventInfoRenderer();


        uiType = Controller.getDefaultUIType();
        this.setUI(uiType);

        Controller.printWelcomeMessage();
        final EventHandler<KeyEvent> keyEventHandler =
                new EventHandler<KeyEvent>() {
                    public void handle(final KeyEvent keyEvent) {
                        Controller.handleKeyEvent(keyEvent);
                    }
                };
        inputText.setOnKeyPressed( keyEventHandler );
        inputText.setOnKeyReleased( keyEventHandler );

        //Create initial list command
        Calendar calendar = Calendar.getInstance();
        QueryList list = new QueryList();
        calendar.set(Calendar.MILLISECOND, 0);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        list.addSearchParam(QueryList.SearchParam.DATE_START, calendar.getTime());
        list.controllerExecute();
    }

    public void getAutomatedCommand(boolean prev) {
        String next;
        if ( prev ) {
            next = CommandAutomation.getInstance().getPrev();
        } else {
            next = CommandAutomation.getInstance().getNext();
        }
        if ( next == null ) {
            return;
        }
        String [] parts = next.split(" // ");
        if ( parts.length == 2 ) {
            pendingAnnouncementMessage = parts[1];
        }
        setUserInput(parts[0]);
        Controller.processIncompleteInput(inputText.getText());
    }

    /**
     * Called by UI when page down key is pressed
     */
    public void taskViewScrollDown() {
        switch ( uiType ) {
            case TIMELINE:
                timelineViewRenderer.getTaskRenderer().scrollUp();
                break;
            case CALENDAR:
                monthViewRenderer.getTaskRenderer().scrollUp();
                break;
            case FLOATING:
                floatingViewRenderer.getTaskRenderer().scrollUp();
                break;
        }
    }

    /**
     * Called by UI when page up key is pressed
     */
    public void taskViewScrollUp() {
        switch ( uiType ) {
            case TIMELINE:
                timelineViewRenderer.getTaskRenderer().scrollDown();
                break;
            case CALENDAR:
                monthViewRenderer.getTaskRenderer().scrollDown();
                break;
            case FLOATING:
                floatingViewRenderer.getTaskRenderer().scrollDown();
                break;
        }
    }
    
    /**
     * Called by UI when End key is pressed
     */
    public void timelineScrollRight() {
        switch ( uiType ) {
            case TIMELINE:
                timelineViewRenderer.getTimelineRenderer().scrollUp();
                break;
        }
    }

    /**
     * Called by UI when home key is pressed
     */
    public void timelineScrollLeft() {
        switch ( uiType ) {
            case TIMELINE:
                timelineViewRenderer.getTimelineRenderer().scrollDown();
                break;
        }
    }

    /**
     * Processes the tab press, fills in the highlighted autocomplete item.
     */
    public void autocompleteSuggestion() {
        if ( firstOption != null && firstOption.length() > 0 ) {
            setUserInput(firstOption + " ");
            Controller.processIncompleteInput(inputText.getText());
        }
    }


    public void setTaskList ( EventList events ) {
        monthViewRenderer.setTaskview(events);
        timelineViewRenderer.setTaskview(events);
        floatingViewRenderer.setTaskview();
        updateTaskList();
    }

    /**
     * Updates the list that the parser holds so it knows what ids to use
     */
    public void updateTaskList() {
        switch ( uiType ) {
            case TIMELINE:
                timelineViewRenderer.setTaskDisplayList();
                break;
            case CALENDAR:
                monthViewRenderer.setTaskDisplayList();
                break;
            case FLOATING:
                floatingViewRenderer.setTaskDisplayList();
                break;
        }
    }

    /**
     * Sets the event list for the week view to display
     * @param events Event
     */
    public void setWeekEventList ( EventList events ) {
        timelineViewRenderer.setWeekView(events);
    }


    public void setAutocompleteOptions( String[] autocompleteOptions, String firstOption ) {
        this.firstOption = firstOption;
        boolean renderFirstLineBold = false;
        if ( firstOption != null && firstOption.length() > 0 ) {
            renderFirstLineBold = true;
        }
        UIRenderer.setAutocompleteOptions(autocompleteOptions, renderFirstLineBold);
        refresh();
    }

    /**
     * Sets the message in the announcement box if any
     * @param message Message to show
     */
    public void setAnnouncementMessage ( String message ) {
        monthViewRenderer.setAnnouncementBoxText(message);
        timelineViewRenderer.setAnnouncementBoxText(message);
        floatingViewRenderer.setAnnouncementBoxText(message);
    }
    public void clearMessageLog() {
        messageList.clear();
        refreshOutputField();
    }

    public void displayMessage( String message ) {
        messageList.add(message);
        refreshOutputField();
    }



    public void setUserInput ( String inputText ) {
        this.inputText.setText(inputText);
        if ( inputText != null ) {
            this.inputText.positionCaret(inputText.length());
        }
    }

    public void refreshOutputField() {
        System.out.println("Refreshing messages");
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < messageList.size(); i++) {
            stringBuilder.append(messageList.get(i));
            stringBuilder.append("\n");
        }

        switch ( uiType ) {
            case CALENDAR:
            case TIMELINE:
                monthViewRenderer.setMessageBoxText(stringBuilder.toString());
                monthViewRenderer.refreshData();
                timelineViewRenderer.setMessageBoxText(stringBuilder.toString());
                timelineViewRenderer.refreshData();
                break;
            case FLOATING:
                floatingViewRenderer.setMessageBoxText(stringBuilder.toString());
                floatingViewRenderer.refreshData();
                break;
            case SETTING:
                break;
        }
        refresh();
    }

    public void refresh() {
        UIRenderer.redraw();
    }

```
###### carelender\view\gui\UIController.java
``` java
    /**
     * Changes the UI back to month view if in settings
     * If not toggle between month and week
     */
    public void toggleUI() {
        if ( uiType == UIType.SETTING ) {
            setUI(UIType.CALENDAR);
        } else {
            if (uiType == UIType.CALENDAR) {
                setUI(UIType.TIMELINE);
            } else {
                setUI(UIType.CALENDAR);
            }
        }
    }

    public void displayPopup( String message ) {
        popupRenderer.setMessage(message);
        UIRenderer.setPopupRenderer(popupRenderer);
        refresh();
    }

    public void displayEventPopup( Event event ) {
        eventInfoRenderer.setEvent(event);
        UIRenderer.setPopupRenderer(eventInfoRenderer);
        refresh();
    }

    public void clearPopup(){
        UIRenderer.setPopupRenderer(null);
        refresh();
    }


    /**
     * Gets the text in the input box
     * @return The text in the input box
     */
    public String getInputboxText() {
        return inputText.getText();
    }

    /**
     * Sets the text in the input box
     * @param text Text to go into the input box
     */
    public void setInputboxText(String text) {
        inputText.setText(text);
    }

    /**
     * Pending announcement message that will be set when enter is pressed
     * @return
     */
    public String getPendingAnnouncementMessage() {
        return pendingAnnouncementMessage;
    }

    public void setPendingAnnouncementMessage(String pendingAnnouncementMessage) {
        this.pendingAnnouncementMessage = pendingAnnouncementMessage;
    }

    public enum UIType {
        CALENDAR, TIMELINE, FLOATING, SETTING
    }

}
```
###### carelender\view\gui\UIRenderer.java
``` java
package carelender.view.gui;

import carelender.view.gui.components.AutocompleteRenderer;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;

/**
 * Used to render the popup and normal layers
 */
public class UIRenderer extends CanvasRenderer {
    private CanvasRenderer mainRenderer;
    private CanvasRenderer popupRenderer;
    AutocompleteRenderer autocompleteRenderer;
    public UIRenderer() {
        autocompleteRenderer = new AutocompleteRenderer();
    }

    @Override
    public void draw(GraphicsContext gc, double x, double y, double width, double height) {
        super.draw(gc, x, y, width, height);
        if ( mainRenderer != null ) {
            mainRenderer.draw(gc, 0, 0, width, height);
        }
        if ( popupRenderer != null ) {
            gc.setGlobalAlpha(0.4);
            gc.setFill(Color.web("#000"));
            gc.fillRect(x,y,width,height);
            gc.setGlobalAlpha(1);
            popupRenderer.draw(gc, width * 0.1, height * 0.1, width * 0.8, height * 0.8);
        }
        autocompleteRenderer.draw(gc, 0, height, width, 0);
    }

    public void setMainRenderer(CanvasRenderer mainRenderer) {
        this.mainRenderer = mainRenderer;
    }

    public void setPopupRenderer(CanvasRenderer popupRenderer) {
        this.popupRenderer = popupRenderer;
    }

    public void setAutocompleteOptions ( String [] options, boolean renderFirstLineBold ) {
        autocompleteRenderer.setAutocompleteOptions(options, renderFirstLineBold);
    }
}
```
###### carelender\view\gui\views\FloatingViewRenderer.java
``` java
package carelender.view.gui.views;

import carelender.controller.Controller;
import carelender.model.data.EventList;
import carelender.model.data.QueryList;
import carelender.model.strings.AppColours;
import carelender.model.strings.FontLoader;
import carelender.view.gui.CanvasRenderer;
import carelender.view.gui.components.*;
import javafx.scene.canvas.GraphicsContext;

public class FloatingViewRenderer extends CanvasRenderer {
    TextRenderer messageBox;
    TextRenderer announcementBox;
    CalenderRenderer calender;

    private QueryList resultsList;
    private EventList listResults;
    private TaskRenderer tasks;

    String messageText, announcementText;
    private TabRenderer tab;

    public FloatingViewRenderer() {
        tasks = new TaskRenderer();
        tasks.setParams(10, 10, 0.7, 0.1, 0.2, 0.1);

        resultsList = new QueryList();
        resultsList.addSearchParam(QueryList.SearchParam.DATE_START, null);
        resultsList.addSearchParam(QueryList.SearchParam.DATE_END, null);
        listResults = new EventList();
        calender = new CalenderRenderer();
        announcementBox = new TextRenderer();
        messageBox = new TextRenderer();
        tab = new TabRenderer();
    }

    @Override
    public void draw( GraphicsContext gc, double x, double y, double width, double height ) {
        super.draw(gc, 0, 0, width, height);
        LayoutHelper.setParams(x,y,width,height);


        tab.draw(gc, 0, 0, width, LayoutHelper.getTopBarHeight(), TabRenderer.FLOATING_INDEX);

        announcementBox.setParams(gc, LayoutHelper.getLeftColumnX(), LayoutHelper.getAnnouncementBoxY(),
                width, LayoutHelper.getAnnouncementHeight(),
                LayoutHelper.getTextboxInnerPadding(), LayoutHelper.getTextboxInnerPadding(),
                LayoutHelper.getFont(), FontLoader.DEFAULT_LINE_HEIGHT_RATIO);
        announcementBox.addText(announcementText);
        announcementBox.drawText(AppColours.panelBackground, AppColours.panelText);

        tasks.draw(gc, LayoutHelper.getLeftColumnX(), LayoutHelper.getMainContentY(),
                width, LayoutHelper.getMainContentHeight());

        messageBox.setParams(gc, LayoutHelper.getLeftColumnX(), LayoutHelper.getMessageBoxY(),
                width , LayoutHelper.getMessageBoxHeight(),
                LayoutHelper.getTextboxInnerPadding(), LayoutHelper.getTextboxInnerPadding(),
                LayoutHelper.getFont(), FontLoader.DEFAULT_LINE_HEIGHT_RATIO);
        messageBox.addText(messageText);
        messageBox.drawText(AppColours.panelBackground, AppColours.panelText);
    }

    /**
     * Sets the text of the announcement box
     * @param text Text to set
     */
    public void setAnnouncementBoxText ( String text ) {
        if ( text != null ) {
            announcementText = text;
        }
    }

    /**
     * Sets the text for the message box
     * @param text Text to set
     */
    public void setMessageBoxText(String text) {
        if ( text != null ) {
            messageText = text;
        }
    }

    public TaskRenderer getTaskRenderer() {
        return tasks;
    }

    public void setTaskview() {
        this.tasks.clearEvents();
        this.listResults = resultsList.searchExecute();
        this.tasks.addEvents(this.listResults);
        redraw();
    }

    /**
     * Sets the display list on the parser so it knows what the indices are
     */
    public void setTaskDisplayList() {
        Controller.setDisplayedList(tasks.getDisplayList());
    }



    public void refreshData() {
        calender.refreshEventList();
    }
}
```
###### carelender\view\gui\views\LayoutHelper.java
``` java
package carelender.view.gui.views;

import carelender.model.strings.FontLoader;
import javafx.scene.text.Font;

/**
 * This class is to do all the layout calculations for the three main views
 * It exists to have a single place to store all the layout parameters since
 * they follow mostly the same layout
 */
public class LayoutHelper {
    private static final double WINDOW_PADDING = 8;
    private static final double TEXTBOX_INNER_PADDING = 8;
    private static final double FONT_RATIO = 1/60.0;
    private static final double TOP_BAR_RATIO = 0.13;
    private static Font font;
    private static double topBarHeight;
    private static double leftColumnX;
    private static double rightColumnX;
    private static double announcementBoxY;
    private static double rightColumnWidth;
    private static double leftColumnWidth;
    private static double mainContentHeight;
    private static double announcementHeight;
    private static double messageBoxHeight;
    private static double mainContentY;
    private static double messageBoxY;


    public static void setParams(double x, double y, double width, double height) {
        double fontSize = width * FONT_RATIO;
        font = FontLoader.load( fontSize );

        topBarHeight = height * TOP_BAR_RATIO;
        double remainderHeight = height - topBarHeight;

        announcementBoxY = topBarHeight + WINDOW_PADDING;

        leftColumnWidth = 0.5 * width - WINDOW_PADDING;
        rightColumnWidth = 0.5 * width;
        leftColumnX = x;
        rightColumnX = leftColumnX + leftColumnWidth + WINDOW_PADDING;

        announcementHeight = fontSize + TEXTBOX_INNER_PADDING * 2;
        messageBoxHeight = fontSize + TEXTBOX_INNER_PADDING * 2;
        mainContentHeight = remainderHeight - announcementHeight - messageBoxHeight - WINDOW_PADDING * 3;
        mainContentY = announcementBoxY + announcementHeight + WINDOW_PADDING;
        messageBoxY = mainContentY + mainContentHeight + WINDOW_PADDING;

    }

    public static Font getFont() {
        return font;
    }

    public static double getLeftColumnX() {
        return leftColumnX;
    }

    public static double getRightColumnX() {
        return rightColumnX;
    }

    public static double getAnnouncementBoxY() {
        return announcementBoxY;
    }

    public static double getMessageBoxHeight() {
        return messageBoxHeight;
    }

    public static double getAnnouncementHeight() {
        return announcementHeight;
    }

    public static double getMainContentHeight() {
        return mainContentHeight;
    }

    public static double getTopBarHeight() {
        return topBarHeight;
    }

    public static double getLeftColumnWidth() {
        return leftColumnWidth;
    }

    public static double getRightColumnWidth() {
        return rightColumnWidth;
    }

    public static double getTextboxInnerPadding() {
        return TEXTBOX_INNER_PADDING;
    }

    public static double getMainContentY() {
        return mainContentY;
    }

    public static double getMessageBoxY() {
        return messageBoxY;
    }
}
```
###### carelender\view\parser\Command.java
``` java
package carelender.view.parser;

import carelender.model.data.QueryType;

import java.util.ArrayList;

/**
 * Used by CommandManager to store a command
 */
public class Command {
    private String command;
    private String description;
    private String usage;
    
    

    private QueryType type;
    ArrayList<CommandKeyword> keywords;
    public Command(String name, QueryType type) {
        command = name.trim();
        this.type = type;
        description = "";
        keywords = new ArrayList<>();
    }

    /**
     * Adds a possible keyword for this command
     *
     * @param type Keyword type
     * @param keyword New keyword
     * @param dataPosition Place to search for the data related to this keyword
     */
    public void addKeyword(String type, String keyword, CommandKeyword.DataPosition dataPosition) {
        keyword = keyword.trim();
        if ( keyword.length() == 0 ) return;
        if ( matchKeyword(keyword) != null ) return;
        keywords.add(new CommandKeyword(keyword, type, dataPosition) );
    }

    /**
     * Adds a list of possible keywords for this command
     *
     * @param type Keyword type
     * @param keywords Comma delimited keyword list
     * @param dataPosition Place to search for the data related to this keyword
     */
    public void addKeywords(String type, String keywords, CommandKeyword.DataPosition dataPosition) {
        String [] keywordArray = keywords.split(",");
        for ( String key: keywordArray ) {
            addKeyword(type,key, dataPosition);
        }
    }
    /**
     * Matches the parts of the command to the keywords
     * @param queryParts Parts of the query
     * @return boolean array with true at the indices of the matched param keywords
     */
    public CommandPart[] processKeywords(String[] queryParts) {
        queryParts = concatenateQueryParts(queryParts);
        CommandPart[] commandParts = new CommandPart[queryParts.length];
        for ( int i = 0 ; i < queryParts.length; i++ ) { //Start from
            CommandKeyword keyword = matchKeyword(queryParts[i]);
            String keywordData = null;
            if ( keyword != null ) {
                if ( keyword.getDataPosition() == CommandKeyword.DataPosition.AFTER ) {
                    if ( i < queryParts.length - 1 ) {
                        keywordData = queryParts[i + 1];
                    }
                } else if (keyword.getDataPosition() == CommandKeyword.DataPosition.BEFORE) {
                    if ( i > 0 ) {
                        keywordData = queryParts[i - 1];
                    }
                }
            }
            commandParts[i] = new CommandPart(  queryParts[i],
                                                keyword!=null,
                                                keyword==null?null:keyword.getType(),
                                                keywordData
                                                );
        }
        return commandParts;
    }

    /**
     * Merges the parts of a string that are surrounded by keywords
     * Does not include the command itself.
     * @return Merged string array
     */
    private String [] concatenateQueryParts(String[] queryParts) {
        ArrayList <String> parts = new ArrayList<>();
        int startingIndex = 1;
        int i = 1;
        while ( true ) {
            if ( i > queryParts.length ) break;
            if ( i == queryParts.length || matchKeyword(queryParts[i]) != null) {
                StringBuilder stringBuilder = new StringBuilder();
                for ( int j = startingIndex; j < i; j++ ) {
                    stringBuilder.append(queryParts[j]);
                    stringBuilder.append(" ");
                }
                parts.add(stringBuilder.toString().trim());
                if ( i < queryParts.length ) {
                    parts.add(queryParts[i]);
                }
                startingIndex = i + 1;
            }
            i++;
        }

        return parts.toArray(new String[parts.size()]);
    }

    /**
     * Checks if a keyword exists
     * @param keyword Parameter to check
     * @return null if not exists
     */
    public CommandKeyword matchKeyword(String keyword) {
        for ( CommandKeyword thisKeyword : keywords) {
            if ( thisKeyword.getKeyword().equalsIgnoreCase(keyword) ) return thisKeyword;
        }
        return null;
    }
    
    public String getUsage() {
        return usage;
    }

    public void setUsage(String usage) {
        this.usage = usage;
    }

    public String getCommand() {
        return command;
    }

    public QueryType getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description.trim();
    }
}
```
###### carelender\view\parser\CommandKeyword.java
``` java
package carelender.view.parser;

/**
 * Used by the Command class to store keywords
 */
public class CommandKeyword {
    String keyword;
    String type;
    DataPosition dataPosition;


    public CommandKeyword(String keyword, String type) {
        this.keyword = keyword;
        this.type = type;
        this.dataPosition = DataPosition.NONE;
    }
    public CommandKeyword(String keyword, String type, DataPosition dataPosition) {
        this.keyword = keyword;
        this.type = type;
        this.dataPosition = dataPosition;
    }

    public String getKeyword() {
        return keyword;
    }

    public String getType() {
        return type;
    }

    public DataPosition getDataPosition() {
        return dataPosition;
    }

    public enum DataPosition {
        NONE, AFTER, BEFORE
    }
}
```
###### carelender\view\parser\CommandManager.java
``` java
package carelender.view.parser;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * Used by the InputParser to sift through the commands
 */
public class CommandManager {
    ArrayList <Command> commands;
    public CommandManager () {
        commands = new ArrayList<>();
    }

    /**
     * Adds a new command to the list of commands
     * @param command The new command
     */
    public void addCommand(Command command) {
        commands.add(command);
    }

    /**
     * Checks if a command exists
     * @param command Command to check against
     * @return Command that has been matched. Null if no match
     */
    public Command matchCommand ( String command ) {
        for ( Command commandObject : commands ) {
            if ( commandObject.getCommand().equalsIgnoreCase( command ) ) {
                return commandObject;
            }
        }
        return null;
    }
}
```
###### carelender\view\parser\CommandPart.java
``` java
package carelender.view.parser;

/**
 * Used by the parser to understand the parts of the command
 */
public class CommandPart {
    private String queryPart; //The original text that was from the user
    private boolean isKeyword; //Is this a keyword?
    private String keywordType; //Type of keyword this is
    private String keywordData; //Data associated with this keyword

    public CommandPart(String queryPart, boolean isKeyword, String keywordType, String keywordData) {
        this.queryPart = queryPart;
        this.isKeyword = isKeyword;
        this.keywordType = keywordType;
        this.keywordData = keywordData;
    }

    public String getQueryPart() {
        return queryPart;
    }

    public boolean isKeyword() {
        return isKeyword;
    }

    public String getKeywordType() {
        return keywordType;
    }

    public String getKeywordData() {
        return keywordData;
    }
}
```
###### carelender\view\parser\DateTimeParser.java
``` java
package carelender.view.parser;

import carelender.model.data.DateRange;
import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Class to parse the date and time bits of the input.
 * Originally using regex, now it uses the natty library
 */
public class DateTimeParser {
```
###### carelender\view\parser\DateTimeParser.java
``` java
    /**
     * Similar to parseDateTimeRaw, but it tries to detect date ranges in the text. This also returns the substrings that contain datetimes.
     * @param inputString Date string to be parsed
     * @param dates ArrayList that contains the parts of the string that the datetime was detected from
     * @return Array of DateRange objects
     */
    public static DateRange[] parseDateTime(String inputString, ArrayList<String> dates) {
        ArrayList<DateRange> dateRanges = new ArrayList<>();
        //Natty cannot process strings like "mon-tue", it needs the space
        inputString = inputString.toLowerCase().replaceAll(" - ", "-");
        inputString = inputString.toLowerCase().replaceAll("-", " - ");
        //Split the string by "and" "," "&"
        String [] inputParts = inputString.split("(and|,|&)");
        for ( int i = 0; i < inputParts.length; i++ ) {
            inputParts[i] = inputParts[i].trim();
        }
        SimpleDateGroup[] dateGroups;

        for ( int i = 0; i < inputParts.length; i++ ) {
            String inputPart = inputParts[i];
            dateGroups = parseDateTimeRaw(inputPart);
            if ( dateGroups == null ) continue;
            //By here, the array should only have one item
            //This loop is in case it has more than one
            for ( SimpleDateGroup dateGroup : dateGroups ) {
                int numberOfDates = dateGroup.dates.length;
                if ( numberOfDates == 1 ) {
                    dateRanges.add(new DateRange(dateGroup.dates[0], dateGroup.hasTime));
                } else if ( numberOfDates == 2 ) {
                    //Should be a range, search for "to" "-"
                    if ( dateGroup.text.contains("to") ||  dateGroup.text.contains("-") ) {
                        //Process as a date range
                        dateRanges.add(new DateRange(dateGroup.dates[0], dateGroup.dates[1], dateGroup.hasTime));
                    } else {
                        //Add as two separate dates
                        dateRanges.add(new DateRange(dateGroup.dates[0], dateGroup.hasTime));
                        dateRanges.add(new DateRange(dateGroup.dates[1], dateGroup.hasTime));
                    }
                } else { //Individual dates
                    for ( Date date : dateGroup.dates ) {
                        dateRanges.add(new DateRange(date, dateGroup.hasTime));
                    }
                }
                if ( dates != null ) {
                    dates.add(dateGroup.text);
                }
            }
        }
        if ( dateRanges.size() == 0 ) {
            return null;
        } else {
            DateRange[] ranges = new DateRange[dateRanges.size()];
            int i = 0;
            for ( DateRange range: dateRanges ) {
                ranges[i] = range;
                i++;
            }
            return ranges;
        }
    }
    /**
     * Parses the date time string and returns an array of SimpleDateGroup objects
     * @param inputString Date string to be parsed
     * @return SimpleDateGroup object array, null if no dates found
     */
    public static SimpleDateGroup[] parseDateTimeRaw (String inputString) {
        assert inputString.length() != 0 : "Cannot parse empty input";

        Parser parser = new Parser();
        List <DateGroup> groups = parser.parse(inputString);
        if ( groups.size() == 0 ) {
            return null;
        }
        SimpleDateGroup [] simpleGroups = new SimpleDateGroup[groups.size()];

        int i = 0;
        for(DateGroup group:groups) {
            List<Date> dates = group.getDates();
            int column = group.getPosition();
            String matchingValue = group.getText();
            boolean hasTime = stringHasTime(matchingValue);
            Date [] dateArray = new Date[dates.size()];
            for ( int j = 0 ; j < dates.size(); j++ ) {
                dateArray[j] = dates.get(j);
            }
            SimpleDateGroup simpleDateGroup = new SimpleDateGroup(dateArray, matchingValue, column, hasTime);
            simpleGroups[i] = simpleDateGroup;
            i++;
        }

        return simpleGroups;
    }

    /**
     * Runs through the date and searches for anything that looks like a time.
     * @param dateString Date string to be searched
     * @return true if there is a semblance of a time
     */
    public static boolean stringHasTime ( String dateString ) {
        //This regex will look for patters like this
        //   "3pm" "5:20a" "4:20" "13:40" "2044 hrs" "1202h" "at 3" "morning" "afternoon" "night" "evening" "noon"
        String timeRegex = "((1[0-2]|[0-9])(:[0-5][0-9])?\\s?(a|p)(m)?)|([0-2]?[0-9]:[0-5][0-9])|([0-2][0-9]:?[0-5][0-9]\\s?(hrs|hr|h))|(at\\s(1[0-2]|[0-9])(:[0-5][0-9])?)|(morning|afternoon|night|evening|noon)";
        return Pattern.compile(timeRegex).matcher(dateString).find();
    }

```
###### carelender\view\parser\DateTimeParser.java
``` java
    /**
     * Gets the date object with times set to 0
     * @param dayOffset Offset the number of days
     * @return Date object
     */
    public static Date getDate ( int dayOffset ) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.MILLISECOND, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.add(Calendar.DATE, dayOffset);
        return calendar.getTime();
    }

    /**
     * Gets the date object with times set to 0
     * @return Date object with today's date
     */
    public static Date getDate () {
        return getDate(0);
    }

}
```
###### carelender\view\parser\InputParser.java
``` java
package carelender.view.parser;

import carelender.model.data.*;
import carelender.model.data.QueryUpdate.UpdateParam;
import carelender.model.strings.ErrorMessages;
import carelender.view.gui.UIController;
import carelender.view.parser.CommandKeyword.DataPosition;
import net.fortuna.ical4j.model.DateTime;

import java.util.*;

/**
 * Parses the user input
 * BasicConfigurator.configure(), put in main. //TODO
 */
public class InputParser {
    private static InputParser singleton = null;
    public static InputParser getInstance() {
        if ( singleton == null ) {
            singleton = new InputParser();
        }
        return singleton;
    }
    CommandManager commandManager;
    //List of displayed events
    private EventList displayedList;

    protected InputParser () {
        commandManager = new CommandManager();
        defineDefaultCommands();
    }

    private void defineDefaultCommands() {
        Command newCommand;

        newCommand = new Command("add", QueryType.ADD);
        newCommand.setDescription("Adds a new event/task");
        newCommand.setUsage("add \"event name\" \"dates\" [cat \"category\"]");
        newCommand.addKeywords("category", "category,cat", CommandKeyword.DataPosition.AFTER);
        commandManager.addCommand(newCommand);

        newCommand = new Command("search", QueryType.LIST);
        newCommand.setDescription("Search for events/tasks");
        newCommand.setUsage("search \"event name\" \"date/daterange\" [cat \"category\"]");
        newCommand.addKeywords("category", "category,cat", CommandKeyword.DataPosition.AFTER);
        newCommand.addKeywords("complete", "complete,completed,finished", null);
        newCommand.addKeywords("incomplete", "incomplete,unfinished", null);
        commandManager.addCommand(newCommand);

        newCommand = new Command("list", QueryType.LIST);
        newCommand.setDescription("List all your future events/tasks");
        newCommand.setUsage("list [past/today/tomorrow/future]");
        newCommand.addKeywords("range", "past,today,tomorrow,future", CommandKeyword.DataPosition.NONE);
        commandManager.addCommand(newCommand);

        
        newCommand = new Command("update", QueryType.UPDATE);
        newCommand.setDescription("Update events/tasks");
        newCommand.setUsage("update <id> [name \"new name\"] [date \"new date\"] [cat \"new category\"]");
        newCommand.addKeywords("name", "name", DataPosition.AFTER);
        newCommand.addKeywords("complete", "complete,finished,finish", DataPosition.AFTER);
        newCommand.addKeywords("category", "cat,category", DataPosition.AFTER);
        newCommand.addKeywords("date", "date,dates,time,times,datetime,datetimes", DataPosition.AFTER);
        commandManager.addCommand(newCommand);

        newCommand = new Command("delete", QueryType.DELETE );
        newCommand.setUsage("delete <id>");
        newCommand.setDescription("Deletes a specified event/task");
        commandManager.addCommand(newCommand);

        newCommand = new Command("show", QueryType.SHOW );
        newCommand.setUsage("show <id>");
        newCommand.setDescription("Displays more information about a specific event/ task");
        commandManager.addCommand(newCommand);

        newCommand = new Command("complete", QueryType.COMPLETE );
        newCommand.setUsage("complete <id>");
        newCommand.setDescription("Completes a specified event/task");
        commandManager.addCommand(newCommand);
        
        newCommand = new Command("uncomplete", QueryType.COMPLETE );
        newCommand.setUsage("uncomplete <id>");
        newCommand.setDescription("Uncompletes a specified event/task");
        commandManager.addCommand(newCommand);
        
        newCommand = new Command("reminder", QueryType.REMINDER );
        newCommand.setUsage("reminder <id> [minutes/hours/days X]");
        newCommand.addKeywords("time", "minute,minutes,hour,hours,day,days", DataPosition.AFTER);
        newCommand.setDescription("Sets a reminder for the specified task");
        commandManager.addCommand(newCommand);

        newCommand = new Command("remind", QueryType.REMINDER );
        newCommand.setUsage("remind <id> [X minutes/hours/days]");
        newCommand.addKeywords("time", "minute,minutes,hour,hours,day,days", DataPosition.AFTER);
        newCommand.setDescription("Sets a reminder for the specified task");
        commandManager.addCommand(newCommand);

        newCommand = new Command("help", QueryType.HELP);
        newCommand.setDescription("Shows the list of commands");
        commandManager.addCommand(newCommand);

        newCommand = new Command("?", QueryType.HELP);
        newCommand.setDescription("Shows the list of commands");
        commandManager.addCommand(newCommand);

        newCommand = new Command("clear", QueryType.CLEAR);
        newCommand.setDescription("Clears the screen");
        commandManager.addCommand(newCommand);

        newCommand = new Command("switch", QueryType.SWITCHUI);
        newCommand.setDescription("Switches the screen");
        commandManager.addCommand(newCommand);

        newCommand = new Command("calendar", QueryType.SWITCHUI);
        newCommand.setDescription("Shows the calendar view");
        commandManager.addCommand(newCommand);

        newCommand = new Command("cal", QueryType.SWITCHUI);
        newCommand.setDescription("Shows the calendar view");
        commandManager.addCommand(newCommand);

        newCommand = new Command("timeline", QueryType.SWITCHUI);
        newCommand.setDescription("Shows the timeline view");
        commandManager.addCommand(newCommand);

        newCommand = new Command("float", QueryType.SWITCHUI);
        newCommand.setDescription("Shows the floating task screen");
        commandManager.addCommand(newCommand);

        newCommand = new Command("floating", QueryType.SWITCHUI);
        newCommand.setDescription("Shows the floating task screen");
        commandManager.addCommand(newCommand);

        newCommand = new Command("settings", QueryType.SWITCHUI);
        newCommand.setDescription("Go to the settings page");
        commandManager.addCommand(newCommand);

        newCommand = new Command("setting", QueryType.SWITCHUI);
        newCommand.setDescription("Go to the settings page");
        commandManager.addCommand(newCommand);

        newCommand = new Command("date", QueryType.DATETEST);
        newCommand.setDescription("Does date parse testing");
        commandManager.addCommand(newCommand);

        newCommand = new Command("undo", QueryType.UNDO);
        newCommand.setDescription("Undoes the last command");
        commandManager.addCommand(newCommand);
        
        newCommand = new Command("redo", QueryType.REDO);
        newCommand.setDescription("Redoes the last undo");
        commandManager.addCommand(newCommand);

        newCommand = new Command("set", QueryType.SET);
        newCommand.setDescription("Customize setting");
        newCommand.setUsage("set \"keyword\" \"newValue\" ");
        newCommand.addKeywords("setting_type", "username,startview", CommandKeyword.DataPosition.AFTER);
        commandManager.addCommand(newCommand);

        newCommand = new Command("exit", QueryType.EXIT);
        newCommand.setDescription("Closes the program");
        commandManager.addCommand(newCommand);

        newCommand = new Command("quit", QueryType.EXIT);
        newCommand.setDescription("Closes the program");
        commandManager.addCommand(newCommand);

        newCommand = new Command("close", QueryType.EXIT);
        newCommand.setDescription("Closes the program");
        commandManager.addCommand(newCommand);
    }

    /**
     * Gets the list of helper options
     * @param userInput User's input
     * @param firstOption Stringbuilder to get the first option of the autocomplete
     * @return String array of options
     */
    public String[] getAutocompleteOptions(String userInput, StringBuilder firstOption) {
        ArrayList <String> options = new ArrayList<>();
        String [] queryParts = splitQuery(userInput);

        if ( (queryParts.length == 1 && userInput.endsWith(" ")) || queryParts.length > 1 ) {
            Command command = commandManager.matchCommand(queryParts[0]);
            if ( command == null ) {
                return null;
            }
            CommandPart [] commandParts = command.processKeywords(queryParts);

            if ( userInput.endsWith(" ") ) {
                //User is not midway through typing a word
                for ( CommandKeyword keyword : command.keywords  ) {
                    CommandPart commandPart = getCommandPart(keyword.getType(), commandParts);
                    if ( commandPart == null ) {
                        //This keyword doesn't exist in the string
                        options.add(userInput + keyword.getKeyword());
                        if ( firstOption != null && firstOption.length() == 0 ) {
                            firstOption.append(userInput + keyword.getKeyword());
                        }
                    }
                }
            } else {
                String lastWord = queryParts[queryParts.length-1];
                queryParts[queryParts.length-1] = "";
                for ( CommandKeyword keyword : command.keywords  ) {
                    CommandPart commandPart = getCommandPart(keyword.getType(), commandParts);
                    if ( commandPart == null ) {
                        //This keyword doesn't exist in the string
                        if ( keyword.getKeyword().startsWith(lastWord) ) {
                            String inputWithoutLastWord = String.join(" ", queryParts);
                            if ( firstOption != null && firstOption.length() == 0 ) {
                                firstOption.append(inputWithoutLastWord + keyword.getKeyword());
                            }
                            options.add(inputWithoutLastWord + keyword.getKeyword());
                        }
                    }

                }
            }

            String usage = command.getUsage();
            if ( usage != null && usage.length() > 0 ) {
                options.add(usage);
            }

            /*for ( CommandKeyword keyword : command.keywords  ) {
                CommandPart commandPart = getCommandPart(keyword.getKeyword(), commandParts);
                if ( commandPart == null ) {
                    //This keyword doesn't exist in the string
                    options.add();
                }
            }*/
            if ( options.size() == 0 ) {
                return null;
            } else {
                return options.toArray(new String[options.size()]);
            }
        } else if ( queryParts.length == 1 ) {
            //Still on first word
            for ( Command command: commandManager.commands ) {
                if ( command.getCommand().toLowerCase().startsWith(userInput.toLowerCase()) ) {
                    if ( firstOption != null && firstOption.length() == 0 ) {
                        firstOption.append(command.getCommand());
                    }
                    options.add(command.getCommand() + " - " + command.getDescription());
                }
            }
            if ( options.size() == 0 ) {
                return null;
            } else {
                return options.toArray(new String[options.size()]);
            }
        } else {
            return null;
        }

    }

    /**
     * Parses the complete user input
     * @param input User's input
     * @return QueryBase object
     */
    public QueryBase parseCompleteInput ( String input ) {
        assert input.length() != 0 : "Cannot parse empty input";
        ArrayList<String> dateSubstrings = new ArrayList<>();
        String [] queryParts = splitQuery(input);
        String commandString = queryParts[0];
        DateRange [] dateRanges = DateTimeParser.parseDateTime(removeQuotes(input), dateSubstrings);

        input = DateTimeParser.replaceDateParts(input, dateSubstrings.toArray(new String[dateSubstrings.size()]), "|DATE|");

        String [] queryPartsNoDate = splitQuery(input);

        Command matchedCommand = commandManager.matchCommand(commandString);

        if ( matchedCommand == null ) { //Error. Command not found.
            return new QueryError(ErrorMessages.invalidCommand(commandString));
        }

        CommandPart[] commandPartsNoDate = matchedCommand.processKeywords(queryPartsNoDate);
        CommandPart[] commandParts = matchedCommand.processKeywords(queryParts);

        QueryBase newQuery;
        switch (matchedCommand.getType()) {
            case ADD:
                newQuery = parseAddCommand(commandPartsNoDate, dateRanges);
                break;
            case DELETE:
                newQuery = parseDeleteCommand(commandParts);
                break;
            case SET:
                newQuery = parseSetCommand(commandParts);
                break;
            case COMPLETE:
                if (commandString.equals("complete")) {
                    newQuery = parseCompleteCommand(commandParts, true);
                } else {
                    newQuery = parseCompleteCommand(commandParts, false);
                }
                break;    
            case UPDATE:
                newQuery = parseUpdateCommand(commandParts);
                break;
            case REMINDER:
                newQuery = parseRemindCommand(commandParts);
                break;
            case LIST:
                if ( matchedCommand.getCommand().equalsIgnoreCase("search") ) {
                    newQuery = parseSearchCommand(dateRanges, commandPartsNoDate);
                } else { //List command
                    newQuery = parseListCommand(queryPartsNoDate, commandParts);
                }
                break;
            case HELP:
                newQuery = new QueryHelp();
                break;
            case SHOW:
                newQuery = parseShowCommand(commandParts);
                break;
            case SWITCHUI:
                if ( matchedCommand.getCommand().startsWith("time") ) {
                    newQuery = new QuerySwitchUI(false, UIController.UIType.TIMELINE);
                } else if ( matchedCommand.getCommand().startsWith("cal")) {
                    newQuery = new QuerySwitchUI(false, UIController.UIType.CALENDAR);
                } else if ( matchedCommand.getCommand().startsWith("float") ) {
                    newQuery = new QuerySwitchUI(false, UIController.UIType.FLOATING);
                } else if ( matchedCommand.getCommand().equalsIgnoreCase("switch") ) {
                    newQuery = new QuerySwitchUI(false);
                } else { //Go to settings
                    newQuery = new QuerySwitchUI(true);
                }
                break;
            case UNDO:
                newQuery = new QueryUndo();
                break;
            case REDO:
                newQuery = new QueryRedo();
                break;
            default:
                newQuery = new QueryGeneric(matchedCommand.getType());
                break;
        }
        return newQuery;
    }

    private QueryBase parseSetCommand(CommandPart [] commandParts) {
        if ( commandParts.length < 3 ) {
            return new QueryError(ErrorMessages.setNoParameters());
        }

        return new QuerySet(commandParts[1].getQueryPart(), commandParts[2].getQueryPart());
    }

    public QueryBase parseSearchCommand ( DateRange[] dateRanges, CommandPart [] commandParts ) {
        QueryList queryList = new QueryList();

        boolean pass = false;
        //Get name data
        if (commandParts.length >= 1 ) { //First item should be the name if it's not a keyword
            if ( !commandParts[0].isKeyword() ) {
                queryList.addSearchParam(QueryList.SearchParam.NAME_CONTAINS, commandParts[0].getQueryPart());
                pass = true;
            }
        }
        //Get date data
        if (dateRanges != null ) {
            if ( dateRanges.length == 1 ) {
                if ( dateRanges[0].hasTime() ) {
                    queryList.addSearchParam(QueryList.SearchParam.DATE_START, dateRanges[0].getStart());
                    queryList.addSearchParam(QueryList.SearchParam.DATE_END, dateRanges[0].getEnd());
                } else {
                    queryList.addSearchParam(QueryList.SearchParam.DATE_START, DateTimeParser.startOfDay(dateRanges[0].getStart()));
                    queryList.addSearchParam(QueryList.SearchParam.DATE_END, DateTimeParser.endOfDay(dateRanges[0].getEnd()));
                }
                pass = true;
            } else {
                return new QueryError(ErrorMessages.tooManyDateRange());
            }
        }

        //Get category data
        CommandPart commandPart = getCommandPart("category", commandParts);
        if ( commandPart != null ) {
            String category = commandPart.getKeywordData();
            if ( category != null ) {
                queryList.addSearchParam(QueryList.SearchParam.CATEGORY, category);
                pass = true;
            }
        }

        commandPart = getCommandPart("complete", commandParts);
        if ( commandPart != null ) {
            queryList.addSearchParam(QueryList.SearchParam.COMPLETE, true);
        }

        commandPart = getCommandPart("incomplete", commandParts);
        if ( commandPart != null ) {
            queryList.addSearchParam(QueryList.SearchParam.COMPLETE, false);
        }

        if ( !pass ) {
            return new QueryError(ErrorMessages.emptySearch());
        }

        return queryList;
    }

    public QueryBase parseListCommand ( String[] queryParts, CommandPart [] commandParts ) {
        QueryList queryList = new QueryList();

        //Check if a relative day keyword exists
        String range = null;
        for ( CommandPart commandPart :commandParts ) {
            if ( commandPart.getKeywordType() != null &&
                    commandPart.getKeywordType().equalsIgnoreCase("range") ) {
                range = commandPart.getQueryPart();
            }
        }

        Date now = new Date();
        Calendar calendar = Calendar.getInstance();

        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MILLISECOND, 0);

        if ( range == null ) {
            queryList.addSearchParam(QueryList.SearchParam.DATE_START, calendar.getTime());
            System.out.println("Default listing");

        } else {
            switch (range) {
                case "past": //Displays events that have passed
                    queryList.addSearchParam(QueryList.SearchParam.DATE_END, now);
                    break;
                case "tomorrow": //Displays events tomorrow onwards
                    calendar.add(Calendar.DAY_OF_MONTH, 1);
                case "today": //Everything for today
                    queryList.addSearchParam(QueryList.SearchParam.DATE_START, calendar.getTime());

                    calendar.set(Calendar.HOUR_OF_DAY, 23);
                    calendar.set(Calendar.MINUTE, 59);
                    queryList.addSearchParam(QueryList.SearchParam.DATE_END, calendar.getTime());
                    break;
                case "future": //Displays events today onwards
                default:
                    System.out.println("Future listing");
                    queryList.addSearchParam(QueryList.SearchParam.DATE_START, calendar.getTime());
                    break;
            }
        }


        return queryList;

    }

    public QueryBase parseShowCommand ( CommandPart [] commandParts ) {
        if ( commandParts.length < 1 ) {
            return new QueryError(ErrorMessages.deleteNoParameters());
        }
        if ( displayedList == null ) {
            return new QueryError(ErrorMessages.nothingListed());
        }

        Integer [] indexList = extractIndices(commandParts[0].getQueryPart());

        if ( indexList == null || indexList.length == 0) {
            return new QueryError(ErrorMessages.invalidIndices());
        }
        if ( indexList.length > 1 ) {
            return new QueryError(ErrorMessages.singleIndexOnly());
        }
        Event event = displayedList.get(indexList[0]);
        return new QueryShow(event);
    }

    public QueryBase parseDeleteCommand ( CommandPart [] commandParts ) {
        if ( commandParts.length < 1 ) {
            return new QueryError(ErrorMessages.deleteNoParameters());
        }
        if ( displayedList == null ) {
            return new QueryError(ErrorMessages.nothingListed());
        }

        Integer [] indexList = extractIndices(commandParts[0].getQueryPart());

        if ( indexList == null ) {
            return new QueryError(ErrorMessages.invalidIndices());
        }
        QueryDelete queryDelete = new QueryDelete();
        for ( int i : indexList ) {
            Event event = displayedList.get(i);
            if ( event != null ) {
                queryDelete.addEvent(event);
            }
        }

        return queryDelete;
    }
    
    public QueryBase parseCompleteCommand ( CommandPart [] commandParts, Boolean forComplete) {
        if ( commandParts.length < 1 ) {
            return new QueryError(ErrorMessages.completeNoParameters());
        }
        if ( displayedList == null ) {
            return new QueryError(ErrorMessages.nothingListed());
        }

        Integer [] indexList = extractIndices(commandParts[0].getQueryPart());

        if ( indexList == null ) {
            return new QueryError(ErrorMessages.invalidIndices());
        }
        QueryComplete queryComplete = new QueryComplete(forComplete);
        for ( int i : indexList ) {
            Event event = displayedList.get(i);
            if ( event != null ) {
                queryComplete.addEvent(event);
            }
        }

        return queryComplete;
    }

    public QueryBase parseRemindCommand ( CommandPart [] commandParts ) {
        if ( commandParts.length < 1 ) {
            return new QueryError(ErrorMessages.remindNoParameters());
        }
        if ( displayedList == null ) {
            return new QueryError(ErrorMessages.nothingListed());
        }

        Integer [] indexList = extractIndices(commandParts[0].getQueryPart());

        if ( indexList == null ) {
            return new QueryError(ErrorMessages.invalidIndices());
        }
        QueryRemind queryRemind = new QueryRemind();
        for ( int i : indexList ) {
            Event event = displayedList.get(i);
            if ( event != null ) {
                queryRemind.addEvent(event);
            }
        }
        String data;
        int timeOffset = 15; //15 minutes as default
        CommandPart commandPart = getCommandPart("time", commandParts);
        if ( commandPart != null ) {
            data = commandPart.getKeywordData();
            System.out.println("parseRemindCommand: data:" + data);
            if ( data != null ) {
                try {
                    timeOffset = Integer.parseInt(data);
                    if (commandPart.getQueryPart().startsWith("hour")) {
                        timeOffset *= 60;
                    }
                    if (commandPart.getQueryPart().startsWith("day")) {
                        timeOffset *= 60 * 24;
                    }
                } catch (NumberFormatException e ) {
                    return new QueryError(ErrorMessages.invalidNumber(data));
                }
            }
        }
        queryRemind.setOffset(timeOffset);

        System.out.println("parseRemindCommand: timeOffset:" + timeOffset);

        return queryRemind;
    }
    
    public QueryBase parseUpdateCommand ( CommandPart [] commandParts ) {
        QueryUpdate queryUpdate = new QueryUpdate();
        
        CommandPart commandPart;
        String data;
        boolean pass = false;
        
        if ( commandParts.length < 1 ) {
            return new QueryError(ErrorMessages.updateNoParameters());
        }
        if ( displayedList == null ) {
            return new QueryError(ErrorMessages.nothingListed());
        }
        
        

        Integer [] indexList = extractIndices(commandParts[0].getQueryPart());

        if ( indexList == null ) {
            return new QueryError(ErrorMessages.invalidIndices());
        }
        
        for ( int i : indexList ) {

            Event event = displayedList.get(i);
            if ( event != null ) {
                queryUpdate.addEvent(event);
            }
        }
        
        commandPart = getCommandPart("name", commandParts);
        if ( commandPart != null ) {
            data = commandPart.getKeywordData();
            if ( data != null ) {
                queryUpdate.addUpdateParam(UpdateParam.NAME, data);
                pass = true;
            }
        }
        
        commandPart = getCommandPart("date", commandParts);
        if ( commandPart != null ) {
            data = commandPart.getKeywordData();
            if ( data != null ) {
                DateRange[] dateRanges = DateTimeParser.parseDateTime(data);
                if ( dateRanges != null ) {
                    queryUpdate.addUpdateParam(UpdateParam.DATE_RANGE, dateRanges);
                    pass = true;
                }
            }
        }
        
        commandPart = getCommandPart("category", commandParts);
        if ( commandPart != null ) {
            data = commandPart.getKeywordData();
            if ( data != null ) {
                queryUpdate.addUpdateParam(UpdateParam.CATEGORY, data);
                pass = true;
            }
        }
        
        if ( !pass ) {
            return new QueryError(ErrorMessages.invalidUpdate());
        }
        

        return queryUpdate;
    }

    public QueryBase parseAddCommand ( CommandPart [] commandParts, DateRange [] dateRanges ) {
        QueryAdd queryAdd = new QueryAdd();

        if ( commandParts.length == 0 ) {
            return new QueryError(ErrorMessages.addNoParameters());
        }
        String name = commandParts[0].getQueryPart(); //First item should be the name
        queryAdd.setName(name);

        if ( dateRanges != null ) {
            queryAdd.setDateRange(dateRanges);
        }

        CommandPart commandPart = getCommandPart("category", commandParts);
        if ( commandPart != null ) {
            String category = commandPart.getKeywordData();
            if ( category != null ) {
                queryAdd.setCategory(category);
            }
        }

        return queryAdd;
    }

    /**
     * Takes the parts of the query and extracts the parts bounded by the indices
     * Returns the string joined by a " "
     * @param queryParts Parts of the query
     * @param start Start index inclusive
     * @param end End index inclusive
     * @return Extracted string
     */
    private String extractString ( String [] queryParts, int start, int end ) {
        StringBuilder stringBuilder = new StringBuilder();
        String space = "";
        for ( int i = start; i <= end && i < queryParts.length; i++ ) {
            stringBuilder.append(space);
            stringBuilder.append(queryParts[i]);
            space = " ";
        }
        return stringBuilder.toString();
    }
    
    /**
     * Changes everything within quotation marks to '='
     * @param input User input
     * @return Processed input
     */
    public String removeQuotes ( String input ) {
        StringBuilder stringBuilder = new StringBuilder();
        boolean masking = false;
        for ( int i = 0; i < input.length(); i++ ) {
            char letter = input.charAt(i);
            if ( letter == '"') {
                masking = !masking;
                stringBuilder.append(letter);
            } else {
                if ( masking ) {
                    stringBuilder.append('=');
                } else {
                    stringBuilder.append(letter);
                }
            }
        }
        return stringBuilder.toString();
    }

    /**
     * Splits up the query into it's individual parts.
     * Also splits by |DATE| string
     * Takes into account "" strings.
     *   e.g. "Hello world" will be converted into one string excluding the "
     * @param input The user input
     * @return String array with each part in it's own entry
     */
    public String [] splitQuery ( String input ) {
        assert input.length() != 0 : "Cannot parse empty input";
        String[] queryParts = input.split("( |\\|DATE\\|)");
        ArrayList<String> processingList = new ArrayList<>(queryParts.length);
        int startString = 0;
        int endString;
        boolean isProcessingString = false;

        for (int i = 0; i < queryParts.length; i++) {
            String part = queryParts[i];
            if (!isProcessingString) {
                //Search for the start of a string
                if (part.startsWith("\"")) {
                    startString = i;
                    isProcessingString = true;
                } else {
                    processingList.add(part);
                }
            }

            if (isProcessingString) {
                //Search for the end of a string
                if (part.endsWith("\"") && part.length() > 1) {
                    endString = i;
                    isProcessingString = false;
                    String extracted = extractString(queryParts, startString, endString);
                    //Add to list and remove the "" wrapping characters.
                    processingList.add(extracted.substring(1, extracted.length() - 1));
                }
            }

            if (isProcessingString && i == queryParts.length - 1) {
                //Unmatched string close. Automatically close
                endString = i;
                isProcessingString = false;
                String extracted = extractString(queryParts, startString, endString);
                //Add to list and remove the initial " characters.
                processingList.add(extracted.substring(1, extracted.length()));
            }
        }
        for (int i = 0; i < queryParts.length; i++) {
            if (i >= processingList.size()) {
                queryParts[i] = "";
            } else {
                queryParts[i] = processingList.get(i);
            }
        }
        queryParts = removeEmptyEntries(queryParts);
        return queryParts;
    }

    /**
     * Gets a command part based on the type
     * @param type Type of keyword
     * @param commandParts commandPart array
     * @return null if it doesn't exist
     */
    protected CommandPart getCommandPart ( String type, CommandPart [] commandParts ) {
        for ( CommandPart commandPart : commandParts ) {
            if ( type.equals(commandPart.getKeywordType())) {
                return commandPart;
            }
        }
        return null;
    }
    /**
     * Takes an index string and converts it into a list of indices
     * Example: "1,13,5-8" will give a list [0,4,5,6,7,12]
     * @param indexString String containing indices
     * @return null if there is an error in parsing
     */
    protected Integer[] extractIndices ( String indexString ) {
        indexString = indexString.replace(" ", "");
        String errorMessage = "";
        boolean pass = true;
        ArrayList<Integer> indexList = new ArrayList<>();
        final String numberRegex = "^[0-9]+$";
        //Parse indices
        String[] indexPartArray = indexString.split(",");
        for ( String indexPart : indexPartArray ) {
            if ( indexPart.contains("-") ) { //Range
                String [] rangeArray = indexPart.split("-");
                if ( rangeArray.length != 2 ) {
                    errorMessage += "Did not understand: [" + indexPart + "]\n";
                    pass = false;
                } else {
                    int start = -1;
                    int end = -1;
                    if ( !rangeArray[0].matches(numberRegex) ) {
                        errorMessage += "Not an integer: [" + rangeArray[0] + "]\n";
                        pass = false;
                    } else {
                        start = Integer.parseInt(rangeArray[0]);
                    }
                    if ( !rangeArray[1].matches(numberRegex) ) {
                        errorMessage += "Not an integer: [" + rangeArray[1] + "]\n";
                        pass = false;
                    } else {
                        end = Integer.parseInt(rangeArray[1]);
                    }

                    //Indices are valid
                    if ( start != -1 && end != -1 ) {
                        if ( start > end ) {
                            int t = start;
                            start = end;
                            end = t;
                        }
                        for ( int i = start; i <= end; i++ ) {
                            indexList.add(i);
                        }
                    }
                }
            } else { //Single index
                int index = -1;
                if ( !indexPart.matches(numberRegex) ) {
                    errorMessage += "Not an integer: [" + indexPart + "]\n";
                    pass = false;
                } else {
                    index = Integer.parseInt(indexPart);
                }

                if ( index != -1 ) {
                    indexList.add(index);
                }
            }
        }

        Collections.sort(indexList);

        if ( displayedList.size() > 0 ) {
            for (int i = 0; i < indexList.size(); i++) {
                int index = indexList.get(i) - 1;
                indexList.set(i, index);
                if (index < 0 || index >= displayedList.size()) {
                    //errorMessage += "Selection is out of bounds\n";
                    pass = false;
                    break;
                }
            }
        } else {
            //errorMessage += "Selection is out of bounds\n";
            pass = false;
        }

        if ( errorMessage.length() > 0 ) {
            System.out.println(errorMessage);
        }
        if ( pass ) {
            return indexList.toArray(new Integer[indexList.size()]);
        }
        return null;
    }
    public String showCommandList() {
        StringBuilder stringBuilder = new StringBuilder();
        String newLine = "  ";
        for ( Command command : commandManager.commands ) {
            stringBuilder.append(newLine);
            newLine = "\n  ";
            stringBuilder.append(command.getCommand());
            stringBuilder.append(": ");
            stringBuilder.append(command.getDescription());
        }
        return stringBuilder.toString();
    }

    /**
     * Removes any entries of a string array that are of length 0
     * @param queryParts String array
     * @return array with empty entries removed
     */
    protected String [] removeEmptyEntries ( String [] queryParts ) {
        int emptyCount = 0;
        for ( String queryPart : queryParts ) {
            if ( queryPart.length() == 0 ) emptyCount++;
        }

        String [] trimmedArray = new String[queryParts.length - emptyCount];
        int trimIndex = 0;
        for ( String queryPart : queryParts ) {
            if ( queryPart.length() != 0 ) {
                trimmedArray[trimIndex] = queryPart;
                trimIndex++;
            }
        }
        return trimmedArray;
    }

    public void setDisplayedList(EventList displayedList) {
        this.displayedList = displayedList;
    }


}
```
###### carelender\view\parser\SimpleDateGroup.java
``` java
package carelender.view.parser;

import java.util.Calendar;
import java.util.Date;

/**
 * Used to store data about the date time parts of the query string
 */
public class SimpleDateGroup {
    Date[] dates;
    String text;
    int position;
    boolean hasTime;

    public SimpleDateGroup(Date[] dates, String text, int position, boolean hasTime) {
        this.dates = dates;
        this.text = text;
        this.position = position;
        this.hasTime = hasTime;
        normaliseTimes(!hasTime);
    }

    /**
     * Helper function to normalise the time components of the dates
     * i.e. Remove the second and millisecond parts
     * @param clearTime If true, it will also remove the hour and minute parts
     */
    private void normaliseTimes(boolean clearTime) {
        Calendar calendar = Calendar.getInstance();
        for ( int i = 0 ; i < dates.length; i++ ) {
            calendar.setTime(dates[i]);
            calendar.set(Calendar.MILLISECOND,0);
            calendar.set(Calendar.SECOND,0);
            if (clearTime) {
                calendar.set(Calendar.HOUR_OF_DAY,0);
                calendar.set(Calendar.MINUTE,0);
            }
            dates[i] = calendar.getTime();
        }
    }
}
```
